<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dPaul Technologies MKIII v3.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #131413;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
            font-family: Verdana, Geneva, sans-serif;
        }

        .synth-container {
            background: #0a0a0a;
            border-radius: 8px;
            padding: 15px 20px 20px 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            max-width: 1600px;
            width: 100%;
            border: 1px solid #1a1a1a;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .synth-header {
            text-align: left;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .power-btn {
            width: 60px;
            height: 32px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 2px solid #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: #666;
            font-family: Verdana, Geneva, sans-serif;
            transition: all 0.2s;
        }

        .power-btn:active {
            transform: scale(0.95);
        }

        .power-btn.on {
            background: linear-gradient(145deg, #8B0000, #5a0000);
            color: #ff0000;
            border-color: #8B0000;
            box-shadow: 0 0 12px rgba(139, 0, 0, 0.6),
                        inset 0 -2px 4px rgba(0,0,0,0.5);
        }

        /* LED Glow effect for labels when powered on */
        .synth-container.powered-on .control-label,
        .synth-container.powered-on .drum-volume-label,
        .synth-container.powered-on .sequencer-title,
        .synth-container.powered-on .tempo-label,
        .synth-container.powered-on .tempo-led-label,
        .synth-container.powered-on .pitch-bend-label,
        .synth-container.powered-on .waveform-label,
        .synth-container.powered-on .preset-label,
        .synth-container.powered-on .info-text,
        .synth-container.powered-on .pad,
        .synth-container.powered-on .seq-btn,
        .synth-container.powered-on .sync-btn,
        .synth-container.powered-on .clear-midi-btn,
        .synth-container.powered-on .waveform-btn,
        .synth-container.powered-on .clear-arp-btn,
        .synth-container.powered-on .preset-btn,
        .synth-container.powered-on .preset-action-btn {
            text-shadow: 0 0 8px currentColor;
        }

        /* Powered off state - dim everything */
        .synth-container.powered-off {
            opacity: 0.3;
            pointer-events: none;
        }

        .synth-container.powered-off .power-btn {
            pointer-events: all;
            opacity: 1;
        }

        /* Dim specific text elements when powered off */
        .synth-container.powered-off .pad,
        .synth-container.powered-off .preset-btn,
        .synth-container.powered-off .preset-action-btn,
        .synth-container.powered-off .tempo-value,
        .synth-container.powered-off .octave-display,
        .synth-container.powered-off .tempo-led-label {
            color: #333 !important;
        }

        /* Stop tempo LED blinking when powered off */
        .synth-container.powered-off .tempo-led {
            background: #0a0a0a !important;
            box-shadow: none !important;
        }

        .synth-title {
            color: #cc5500;
            font-size: 18px;
            font-weight: normal;
            font-family: 'Courier New', Courier, monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 8px rgba(204, 85, 0, 0.3);
        }

        .synth-title .bold {
            color: white;
            font-weight: bold;
        }

        .synth-title .mkii {
            color: white;
            font-weight: bold;
        }

        .controls-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 6px;
        }

        .control-section {
            background: #000;
            border: 1px solid #1a1a1a;
            border-radius: 6px;
            padding: 12px;
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .control-label {
            color: #666;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .knob {
            width: 32px;
            height: 32px;
            background: radial-gradient(circle at 30% 30%, #2a2a2a, #0a0a0a);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5),
                        inset 0 -2px 4px rgba(0,0,0,0.8),
                        inset 0 2px 4px rgba(255,255,255,0.05);
            border: 1px solid #1a1a1a;
        }

        .knob::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 12px;
            background: #ff6b6b;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(255, 107, 107, 0.8);
        }

        .knob-value {
            color: #ff6b6b;
            font-size: 8px;
            margin-top: 2px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .switch {
            width: 45px;
            height: 22px;
            background: #0a0a0a;
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            border: 1px solid #1a1a1a;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8);
        }

        .switch.active {
            background: #ff6b6b;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.5),
                        inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #2a2a2a;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .switch.active::after {
            transform: translateX(23px);
            background: #fff;
        }

        .drum-pads {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 6px;
            margin-bottom: 6px;
            justify-items: center;
        }

        .drum-pad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .pad {
            width: 48px;
            height: 28px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 7px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
            border: 1px solid #1a1a1a;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5);
            transition: all 0.1s;
        }

        .pad:active {
            transform: scale(0.95);
            background: #ff6b6b;
            color: white;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
        }

        .pad.selected {
            border: 2px solid #cc5500;
            box-shadow: 0 0 10px rgba(204, 85, 0, 0.5);
        }

        .drum-volume-switch {
            display: flex;
            gap: 2px;
            align-items: center;
        }

        .volume-dot {
            width: 6px;
            height: 6px;
            background: #1a1a1a;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid #2a2a2a;
            transition: all 0.1s;
        }

        .volume-dot.active {
            background: #cc5500;
            box-shadow: 0 0 6px rgba(204, 85, 0, 0.6);
        }

        .sample-section {
            margin-bottom: 6px;
            padding: 8px;
            background: #000;
            border-radius: 6px;
            border: 1px solid #1a1a1a;
        }

        .sample-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .sample-title {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .sample-pads {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 6px;
            justify-items: center;
        }

        .sample-pad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            position: relative;
        }

        .sample-pad {
            width: 48px;
            height: 28px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 7px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
            border: 1px solid #1a1a1a;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5);
            transition: all 0.1s;
            position: relative;
        }

        .sample-pad:active {
            transform: scale(0.95);
            background: #ff6b6b;
            color: white;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
        }

        .sample-pad.selected {
            border: 2px solid #cc5500;
            box-shadow: 0 0 10px rgba(204, 85, 0, 0.5);
        }

        .sample-pad.loaded {
            border: 2px solid #00ff00;
            box-shadow: 0 0 6px rgba(0, 255, 0, 0.4);
        }

        .sample-pad.loaded.selected {
            border: 2px solid #cc5500;
            box-shadow: 0 0 10px rgba(204, 85, 0, 0.5);
        }

        .load-sample-btn {
            width: 42px;
            height: 16px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 3px;
            color: #666;
            cursor: pointer;
            font-size: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            transition: all 0.1s;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .load-sample-btn:active {
            transform: scale(0.95);
            background: #cc5500;
            color: white;
        }

        .clear-sample-btn {
            width: 42px;
            height: 14px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 3px;
            color: #666;
            cursor: pointer;
            font-size: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            transition: all 0.1s;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .clear-sample-btn:active {
            transform: scale(0.95);
            background: #ff6b6b;
            color: white;
        }

        .sampler-controls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            padding: 8px;
            background: #0a0a0a;
            border-radius: 4px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .sampler-control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .sampler-label {
            color: #666;
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .sampler-knob {
            width: 32px;
            height: 32px;
            background: radial-gradient(circle at 30% 30%, #2a2a2a, #0a0a0a);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5),
                        inset 0 -2px 4px rgba(0,0,0,0.8),
                        inset 0 2px 4px rgba(255,255,255,0.05);
            border: 1px solid #1a1a1a;
        }

        .sampler-knob::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 10px;
            background: #00ff00;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(0, 255, 0, 0.8);
        }

        .sampler-value {
            color: #00ff00;
            font-size: 7px;
            margin-top: 2px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .sampler-switch {
            width: 40px;
            height: 20px;
            background: #0a0a0a;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 1px solid #1a1a1a;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8);
        }

        .sampler-switch.active {
            background: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5),
                        inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .sampler-switch::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: #2a2a2a;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .sampler-switch.active::after {
            transform: translateX(20px);
            background: #fff;
        }

        .pitch-bend-container {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 5px;
        }

        .pitch-bend-label {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 0;
            letter-spacing: 0.5px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }

        .pitch-bend {
            width: 40px;
            height: 100px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 20px;
            position: relative;
            cursor: pointer;
        }

        .pitch-bend-thumb {
            width: 36px;
            height: 25px;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 1px solid #3a3a3a;
            border-radius: 13px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 37.5px;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            transition: background 0.1s;
        }

        .pitch-bend-thumb:active {
            cursor: grabbing;
            background: #cc5500;
        }

        .pitch-bend-center {
            position: absolute;
            width: 100%;
            height: 2px;
            background: #cc5500;
            top: 50%;
            left: 0;
            opacity: 0.3;
        }

        .pitch-hold-btn {
            width: 40px;
            height: 30px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            font-family: Verdana, Geneva, sans-serif;
            font-weight: bold;
            margin-top: 8px;
            transition: all 0.1s;
        }

        .pitch-hold-btn:active {
            transform: scale(0.95);
        }

        .pitch-hold-btn.active {
            background: #cc5500;
            color: white;
            box-shadow: 0 0 8px rgba(204, 85, 0, 0.5);
        }

        .sequencer {
            margin-bottom: 6px;
            padding: 8px;
            background: #000;
            border-radius: 6px;
            border: 1px solid #1a1a1a;
        }

        .sequencer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .sequencer-title {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .sequencer-controls {
            display: flex;
            gap: 8px;
        }

        .seq-btn {
            padding: 5px 12px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .seq-btn:active {
            transform: scale(0.95);
        }

        .seq-btn.active {
            background: #cc5500;
            color: white;
            box-shadow: 0 0 8px rgba(204, 85, 0, 0.5);
        }

        .sequencer-grid {
            display: grid;
            grid-template-columns: repeat(32, 1fr);
            gap: 4px;
        }

        .step {
            width: 100%;
            aspect-ratio: 1;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
        }

        .step.hidden {
            display: none;
        }

        .step.active {
            background: #cc5500;
            box-shadow: 0 0 8px rgba(204, 85, 0, 0.6);
        }

        .step.playing {
            box-shadow: 0 0 12px rgba(255, 107, 107, 1);
            border-color: #ff6b6b;
        }

        .step-number {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 7px;
            color: #444;
        }

        .tempo-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .tempo-label {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
        }

        .tempo-value {
            color: #cc5500;
            font-size: 10px;
            font-weight: bold;
            min-width: 60px;
            font-family: Verdana, Geneva, sans-serif;
        }

        .tempo-slider {
            flex: 1;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .tempo-slider::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: var(--tempo-width, 50%);
            background: #cc5500;
            border-radius: 2px;
        }

        .tempo-btn {
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            user-select: none;
        }

        .tempo-btn:active {
            transform: scale(0.95);
            background: #cc5500;
            color: white;
        }

        .bpm-indicator {
            width: 12px;
            height: 12px;
            background: #1a1a1a;
            border-radius: 50%;
            border: 1px solid #2a2a2a;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.8);
            transition: all 0.1s;
        }

        .bpm-indicator.beat {
            background: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8),
                        inset 0 0 4px rgba(255, 100, 100, 0.5);
        }

        .tempo-led-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
        }

        .tempo-led-label {
            color: #666;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .tempo-led {
            width: 14px;
            height: 14px;
            background: #0a2a0a;
            border-radius: 2px;
            border: 1px solid #1a3a1a;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.8);
            transition: all 0.08s;
        }

        .tempo-led.blink {
            background: #00ff00;
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.9),
                        inset 0 0 6px rgba(150, 255, 150, 0.6);
        }

        .sync-btn {
            padding: 5px 12px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            text-transform: uppercase;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .sync-btn:active {
            transform: scale(0.95);
        }

        .sync-btn.active {
            background: #cc5500;
            color: white;
            box-shadow: 0 0 8px rgba(204, 85, 0, 0.5);
        }

        .drum-volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .drum-volume-label {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .drum-knob {
            width: 38px;
            height: 38px;
            background: radial-gradient(circle at 30% 30%, #2a2a2a, #0a0a0a);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5),
                        inset 0 -2px 4px rgba(0,0,0,0.8),
                        inset 0 2px 4px rgba(255,255,255,0.05);
            border: 1px solid #1a1a1a;
        }

        .drum-knob::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 15px;
            background: #cc5500;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(204, 85, 0, 0.8);
        }

        .drum-knob-value {
            color: #cc5500;
            font-size: 10px;
            margin-top: 3px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .keyboard {
            position: relative;
            height: 70px;
            margin-top: 10px;
            display: flex;
            justify-content: center;
            padding-left: 64px;
            flex-shrink: 0;
        }

        .piano-keys {
            position: relative;
            display: inline-block;
        }

        .white-key {
            width: 26px;
            height: 70px;
            background: linear-gradient(180deg, #fafafa 0%, #d0d0d0 100%);
            border: 1px solid #1a1a1a;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            display: inline-block;
            position: relative;
            cursor: pointer;
            vertical-align: top;
            margin-right: -1px;
            transition: all 0.05s ease;
        }

        .white-key:active,
        .white-key.playing {
            background: linear-gradient(180deg, #ff6b6b 0%, #ff8787 100%);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
            transform: translateY(2px);
        }

        .black-key {
            width: 18px;
            height: 45px;
            background: linear-gradient(180deg, #1a1a1a 0%, #000 100%);
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            position: absolute;
            z-index: 10;
            box-shadow: 0 3px 8px rgba(0,0,0,0.6);
            cursor: pointer;
            top: 0;
            transition: all 0.05s ease;
        }

        .black-key:active,
        .black-key.playing {
            background: linear-gradient(180deg, #ff6b6b 0%, #ff4757 100%);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
            transform: translateY(2px);
            height: 43px;
        }

        .visualizer {
            width: 100%;
            height: 18px;
            background: #000;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #1a1a1a;
            overflow: hidden;
            position: relative;
        }

        .wave-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wave-bar {
            width: 2px;
            background: #ff6b6b;
            margin: 0 1px;
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(255, 107, 107, 0.5);
            transition: height 0.1s;
        }

        @keyframes glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-light {
            width: 8px;
            height: 8px;
            background: #1a1a1a;
            border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.8);
        }

        .status-light.active {
            background: #ff6b6b;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.8);
            animation: glow 1s infinite;
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            padding: 6px;
            background: #000;
            border-radius: 6px;
            border: 1px solid #1a1a1a;
        }

        .song-controls {
            display: flex;
            gap: 6px;
        }

        .song-btn {
            padding: 5px 10px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 9px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            text-transform: uppercase;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .song-btn:active {
            transform: scale(0.95);
            background: #00ff00;
            color: #000;
        }

        .info-text {
            color: #666;
            font-size: 10px;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .clear-midi-btn {
            padding: 5px 12px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 9px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            text-transform: uppercase;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .clear-midi-btn:active {
            transform: scale(0.95);
            background: #ff6b6b;
            color: white;
        }

        .octave-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .octave-btn {
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            font-family: Verdana, Geneva, sans-serif;
        }

        .octave-btn:active {
            transform: scale(0.95);
            background: #ff6b6b;
            color: white;
        }

        .octave-display {
            color: #ff6b6b;
            font-size: 12px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            font-family: Verdana, Geneva, sans-serif;
        }

        .preset-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #000;
            border-radius: 6px;
            border: 1px solid #1a1a1a;
            margin-top: 8px;
            gap: 8px;
        }

        .preset-label {
            color: #cc5500;
            font-size: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-family: Verdana, Geneva, sans-serif;
        }

        .preset-buttons {
            display: flex;
            gap: 5px;
            flex: 1;
            justify-content: center;
        }

        .preset-btn {
            width: 36px;
            height: 26px;
            background: #8B0000;
            border: 2px solid #ff0000;
            border-radius: 3px;
            color: #ff0000;
            cursor: pointer;
            font-size: 9px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            font-family: Verdana, Geneva, sans-serif;
        }

        .preset-btn:active {
            transform: scale(0.95);
        }

        .preset-btn.selected {
            background: #ff0000;
            color: #000;
            box-shadow: 0 0 12px rgba(255, 0, 0, 0.8);
        }

        .preset-actions {
            display: flex;
            gap: 5px;
        }

        .preset-action-btn {
            padding: 5px 8px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 2px solid #cc5500;
            border-radius: 3px;
            color: #cc5500;
            cursor: pointer;
            font-size: 7px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            transition: all 0.1s;
            font-family: Verdana, Geneva, sans-serif;
        }

        .preset-action-btn:active {
            transform: scale(0.95);
            background: #cc5500;
            color: #000;
        }

        .waveform-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            padding: 6px;
            background: #000;
            border-radius: 6px;
            border: 1px solid #1a1a1a;
        }

        .waveform-label {
            color: #666;
            font-size: 8px;
            font-weight: bold;
            text-transform: uppercase;
            font-family: Verdana, Geneva, sans-serif;
        }

        .waveform-btn {
            padding: 5px 10px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 9px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .waveform-btn:active {
            transform: scale(0.95);
        }

        .waveform-btn.active {
            background: #cc5500;
            color: white;
            box-shadow: 0 0 8px rgba(204, 85, 0, 0.5);
        }

        .clear-arp-btn {
            padding: 5px 12px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 9px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            transition: all 0.1s;
            text-transform: uppercase;
            font-weight: bold;
            font-family: Verdana, Geneva, sans-serif;
        }

        .clear-arp-btn:active {
            transform: scale(0.95);
            background: #cc5500;
            color: white;
        }

        /* ── Wavetable Browser Modal ── */
        #wavetableModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }
        #wavetableModal.open { display: flex; }
        .wt-modal-inner {
            background: #111;
            border: 1px solid #cc5500;
            border-radius: 12px;
            width: min(720px, 95vw);
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(204,85,0,0.3);
        }
        .wt-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            border-bottom: 1px solid #333;
            background: #0d0d0d;
        }
        .wt-modal-header h2 {
            color: #cc5500;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            letter-spacing: 2px;
            margin: 0;
        }
        .wt-close-btn {
            background: none;
            border: 1px solid #555;
            color: #aaa;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .wt-close-btn:hover { border-color: #cc5500; color: #cc5500; }
        .wt-search-bar {
            padding: 10px 18px;
            background: #0d0d0d;
            border-bottom: 1px solid #222;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .wt-search-bar input {
            flex: 1;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            outline: none;
        }
        .wt-search-bar input:focus { border-color: #cc5500; }
        .wt-status {
            color: #888;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            min-width: 80px;
            text-align: right;
        }
        .wt-upload-label {
            background: #1a1a1a;
            border: 1px solid #555;
            color: #aaa;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: nowrap;
        }
        .wt-upload-label:hover { border-color: #cc5500; color: #cc5500; }
        .wt-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 8px;
            padding: 14px 18px;
            overflow-y: auto;
            flex: 1;
        }
        .wt-card {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: border-color 0.15s, background 0.15s;
            position: relative;
        }
        .wt-card:hover { border-color: #cc5500; background: #222; }
        .wt-card.active { border-color: #cc5500; background: #1f1100; }
        .wt-card .wt-name {
            color: #eee;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 4px;
            word-break: break-word;
        }
        .wt-card .wt-sub {
            color: #666;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }
        .wt-card .wt-loading {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            color: #cc5500;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }
        .wt-current-label {
            padding: 8px 18px;
            background: #0d0d0d;
            border-top: 1px solid #222;
            color: #cc5500;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="synth-container powered-on" id="synthContainer">
        <div class="synth-header">
            <div class="synth-title">dPaul Technologies MKIII <span style="font-size: 12px; color: #666;">v3.0</span></div>
            <div style="display: flex; gap: 12px; align-items: center;">
                <div class="tempo-led-container">
                    <div class="tempo-led-label">TEMPO</div>
                    <div class="tempo-led" id="tempoLed"></div>
                </div>
                <div class="power-btn on" id="powerBtn">ON</div>
            </div>
        </div>

        <div class="visualizer">
            <div class="wave-container" id="visualizer"></div>
        </div>

        <div class="waveform-section">
            <div class="waveform-label">WAVE</div>
            <div class="waveform-btn active" id="waveSaw" data-wave="sawtooth">SAW</div>
            <div class="waveform-btn" id="waveSquare" data-wave="square">SQR</div>
            <div class="waveform-btn" id="waveTri" data-wave="triangle">TRI</div>
            <div class="waveform-btn" id="waveSine" data-wave="sine">SIN</div>
            <div class="waveform-btn" id="wavePulse" data-wave="pulse">PULSE</div>
            <div class="waveform-btn" id="waveNoise" data-wave="noise">NOISE</div>
            <div class="waveform-btn" id="waveWavetable" data-wave="wavetable">WTBL</div>
            <div class="clear-arp-btn" id="clearArpBtn">CLEAR ARP</div>
        </div>

        <div class="controls-panel">
            <!-- Section 1: Effects -->
            <div class="control-section">
                <div class="control-group">
                    <div class="control-label">DELAY</div>
                    <div class="knob" id="delayKnob" data-value="50"></div>
                    <div class="knob-value" id="delayValue">50%</div>
                </div>
                <div class="control-group">
                    <div class="control-label">FEEDBACK</div>
                    <div class="knob" id="feedbackKnob" data-value="30"></div>
                    <div class="knob-value" id="feedbackValue">30%</div>
                </div>
                <div class="control-group">
                    <div class="control-label">FILTER</div>
                    <div class="knob" id="filterKnob" data-value="80"></div>
                    <div class="knob-value" id="filterValue">80%</div>
                </div>
                <div class="control-group">
                    <div class="control-label">RESONANCE</div>
                    <div class="knob" id="resonanceKnob" data-value="20"></div>
                    <div class="knob-value" id="resonanceValue">20%</div>
                </div>
            </div>

            <!-- Section 2: Volume & ARP -->
            <div class="control-section">
                <div class="control-group">
                    <div class="control-label">SYNTH VOL</div>
                    <div class="knob" id="synthVolumeKnob" data-value="70"></div>
                    <div class="knob-value" id="synthVolumeValue">70%</div>
                </div>
                <div class="control-group">
                    <div class="control-label">DRUM VOL</div>
                    <div class="drum-knob knob" id="drumVolumeKnob" data-value="70"></div>
                    <div class="drum-knob-value knob-value" id="drumVolumeValue">70%</div>
                </div>
                <div class="control-group">
                    <div class="control-label">MASTER</div>
                    <div class="knob" id="masterVolumeKnob" data-value="70"></div>
                    <div class="knob-value" id="masterVolumeValue">70%</div>
                </div>
                <div class="control-group">
                    <div class="control-label">ARP</div>
                    <div class="switch" id="arpSwitch"></div>
                    <div class="status-light" id="arpLight"></div>
                </div>
                <div class="control-group">
                    <div class="control-label">ARP MODE</div>
                    <div style="display: flex; gap: 3px; flex-wrap: wrap; justify-content: center;">
                        <div class="seq-btn active" id="arpUp" data-mode="up" style="font-size: 7px; padding: 3px 6px;">UP</div>
                        <div class="seq-btn" id="arpDown" data-mode="down" style="font-size: 7px; padding: 3px 6px;">DN</div>
                        <div class="seq-btn" id="arpUpDown" data-mode="updown" style="font-size: 7px; padding: 3px 6px;">U/D</div>
                        <div class="seq-btn" id="arpRandom" data-mode="random" style="font-size: 7px; padding: 3px 6px;">RND</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="sequencer">
            <div class="sequencer-header">
                <div class="sequencer-title">DRUM SEQUENCER</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <div class="bpm-indicator" id="bpmIndicator"></div>
                    <div class="seq-btn" id="steps8Btn" data-steps="8">8</div>
                    <div class="seq-btn" id="steps16Btn" data-steps="16">16</div>
                    <div class="seq-btn active" id="steps32Btn" data-steps="32">32</div>
                    <div class="sync-btn" id="syncBtn">SYNC</div>
                    <div class="sequencer-controls">
                        <div class="seq-btn" id="playSeq">PLAY</div>
                        <div class="seq-btn" id="stopSeq">STOP</div>
                        <div class="seq-btn" id="clearSeq">CLEAR</div>
                    </div>
                </div>
            </div>
            <div class="sequencer-grid" id="sequencerGrid"></div>
            <div class="tempo-control">
                <div class="tempo-label">TEMPO</div>
                <div class="tempo-btn" id="tempoDown">-</div>
                <div class="tempo-slider" id="tempoSlider"></div>
                <div class="tempo-btn" id="tempoUp">+</div>
                <div class="tempo-value" id="tempoValue">120 BPM</div>
            </div>
        </div>

        <div class="drum-pads">
            <div class="drum-pad-container">
                <div class="pad" data-sound="kick">KICK</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="kick" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="kick" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="kick" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="snare">SNARE</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="snare" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="snare" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="snare" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="hihat">HIHAT</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="hihat" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="hihat" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="hihat" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="clap">CLAP</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="clap" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="clap" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="clap" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="tom1">TOM1</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="tom1" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="tom1" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="tom1" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="tom2">TOM2</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="tom2" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="tom2" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="tom2" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="cymbal">CYMBAL</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="cymbal" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="cymbal" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="cymbal" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="perc">PERC</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="perc" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="perc" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="perc" data-level="1.0"></div>
                </div>
            </div>
            <div class="drum-pad-container">
                <div class="pad" data-sound="shaker">SHAKER</div>
                <div class="drum-volume-switch">
                    <div class="volume-dot" data-drum="shaker" data-level="0.3"></div>
                    <div class="volume-dot active" data-drum="shaker" data-level="0.7"></div>
                    <div class="volume-dot" data-drum="shaker" data-level="1.0"></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-text">37-KEY ANALOG SYNTHESIZER</div>
            <div class="song-controls">
                <div class="song-btn" id="saveLocalBtn">SAVE LOCAL</div>
                <div class="song-btn" id="loadLocalBtn">LOAD LOCAL</div>
                <div class="song-btn" id="saveDriveBtn">SAVE DRIVE</div>
                <div class="song-btn" id="loadDriveBtn">LOAD DRIVE</div>
                <input type="file" id="loadSongFile" accept=".json" style="display:none">
            </div>
            <div class="clear-midi-btn" id="clearMidiBtn">CLEAR MIDI</div>
            <div class="octave-controls">
                <div class="octave-btn" id="octaveDown">-</div>
                <div class="octave-display" id="octaveDisplay">OCT 4</div>
                <div class="octave-btn" id="octaveUp">+</div>
            </div>
            <div class="info-text" id="noteDisplay" style="display:none;">---</div>
        </div>

        <div class="preset-section">
            <div class="preset-label">MEMORY</div>
            <div class="preset-buttons">
                <div class="preset-btn" id="preset1" data-preset="1">M1</div>
                <div class="preset-btn" id="preset2" data-preset="2">M2</div>
                <div class="preset-btn" id="preset3" data-preset="3">M3</div>
            </div>
            <div class="preset-actions">
                <div class="preset-action-btn" id="savePreset">SAVE</div>
                <div class="preset-action-btn" id="loadPreset">LOAD</div>
            </div>
        </div>

        <div class="keyboard">
            <div class="pitch-bend-container">
                <div class="pitch-bend" id="pitchBend">
                    <div class="pitch-bend-center"></div>
                    <div class="pitch-bend-thumb" id="pitchBendThumb"></div>
                </div>
                <div class="pitch-bend-label">PITCH</div>
                <div class="pitch-hold-btn" id="pitchHoldBtn">HOLD</div>
            </div>
            <div class="piano-keys" id="pianoKeys"></div>
        </div>
    </div>

    <script>
        console.log('SCRIPT STARTED - TOP OF FILE');
        
        // Audio Context
        let audioContext;
        let masterGain;
        let synthGain;
        let drumGain;
        let delayNode;
        let feedbackGain;
        let filterNode;
        
        // Synth state
        let currentOctave = 4;
        let arpEnabled = false;
        let arpInterval = null;
        let arpNotes = [];
        let arpIndex = 0;
        let arpMode = 'up'; // 'up', 'down', 'updown', 'random'
        let arpDirection = 1; // 1 for up, -1 for down (used in updown mode)
        let activeNotes = new Map();
        let pitchBendValue = 0; // -1 to 1
        let pitchHoldEnabled = false; // Pitch hold state
        let synthPowered = true; // Synth power state
        let syncEnabled = false;
        let midiAccess = null;
        let midiInputs = [];
        let selectedPreset = 1; // Currently selected preset slot (1, 2, or 3)
        let currentWaveform = 'sawtooth'; // Current waveform: sawtooth, square, triangle, sine
        let presets = {
            1: null,
            2: null,
            3: null
        };
        
        // Individual drum volumes (0-1)
        let drumVolumes = {
            kick: 0.7,
            snare: 0.7,
            hihat: 0.7,
            clap: 0.7,
            tom1: 0.7,
            tom2: 0.7,
            cymbal: 0.7,
            perc: 0.7,
            shaker: 0.7
        };
        
        // Sequencer state
        let selectedDrum = 'kick';
        let selectedSample = null; // Currently selected sample for sequencing
        let sampleBuffers = {}; // Loaded audio buffers for samples (0-9)
        let samplePitch = 0; // -12 to +12 semitones
        let sampleSpeed = 1.0; // 0.5 to 2.0x
        let sampleFilter = 20000; // 200 to 20000 Hz
        let sampleReverse = false;
        let sampleLoop = false;
        let sequencerPattern = {
            kick: Array(32).fill(false),
            snare: Array(32).fill(false),
            hihat: Array(32).fill(false),
            clap: Array(32).fill(false),
            tom1: Array(32).fill(false),
            tom2: Array(32).fill(false),
            cymbal: Array(32).fill(false),
            perc: Array(32).fill(false),
            shaker: Array(32).fill(false),
            sample0: Array(32).fill(false),
            sample1: Array(32).fill(false),
            sample2: Array(32).fill(false),
            sample3: Array(32).fill(false),
            sample4: Array(32).fill(false),
            sample5: Array(32).fill(false),
            sample6: Array(32).fill(false),
            sample7: Array(32).fill(false),
            sample8: Array(32).fill(false),
            sample9: Array(32).fill(false)
        };
        let sequencerPlaying = false;
        let sequencerInterval = null;
        let currentStep = 0;
        let tempo = 120;
        let tempoLedInterval = null;
        let sequencerSteps = 32; // 8, 16, or 32 steps

        // Note names
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Initialize Audio
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.7;
                
                synthGain = audioContext.createGain();
                synthGain.gain.value = 0.7;
                
                drumGain = audioContext.createGain();
                drumGain.gain.value = 0.7;
                
                delayNode = audioContext.createDelay();
                delayNode.delayTime.value = 0.3;
                
                feedbackGain = audioContext.createGain();
                feedbackGain.gain.value = 0.3;
                
                filterNode = audioContext.createBiquadFilter();
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 2000;
                filterNode.Q.value = 1;
                
                // Routing: synth → delay/filter → synthGain → masterGain → output
                //          drums → drumGain → masterGain → output
                delayNode.connect(feedbackGain);
                feedbackGain.connect(delayNode);
                delayNode.connect(filterNode);
                filterNode.connect(synthGain);
                
                synthGain.connect(masterGain);
                drumGain.connect(masterGain);
                masterGain.connect(audioContext.destination);
            }
        }

        function getNoteFrequency(noteIndex, octave) {
            const A4 = 440;
            const C4_INDEX = -9;
            const semitonesFromA4 = (octave - 4) * 12 + noteIndex + C4_INDEX;
            return A4 * Math.pow(2, semitonesFromA4 / 12);
        }

        function playNote(frequency, noteName) {
            initAudio();
            
            const now = audioContext.currentTime;
            
            // Apply pitch bend (±2 semitones)
            const bendedFrequency = frequency * Math.pow(2, (pitchBendValue * 2) / 12);
            
            // Handle noise waveform differently
            if (currentWaveform === 'noise') {
                const bufferSize = audioContext.sampleRate * 0.5;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = bendedFrequency;
                noiseFilter.Q.value = 10;
                
                const envelope = audioContext.createGain();
                envelope.gain.value = 0;
                envelope.gain.setValueAtTime(0, now);
                envelope.gain.linearRampToValueAtTime(0.2, now + 0.02);
                envelope.gain.linearRampToValueAtTime(0.15, now + 0.15);
                
                noise.connect(noiseFilter);
                noiseFilter.connect(envelope);
                envelope.connect(filterNode);
                envelope.connect(delayNode);
                
                noise.start(now);
                
                activeNotes.set(noteName, { noise, envelope, baseFrequency: frequency, noiseFilter });
                
                animateVisualizer();
                updateNoteDisplay(noteName);
                return { noise, envelope };
            }
            
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const osc3 = audioContext.createOscillator();
            
            // Handle pulse wave (narrow square wave)
            if (currentWaveform === 'pulse') {
                const real = new Float32Array([0, 0, 1, 0, 0.5, 0, 0.3]);
                const imag = new Float32Array(real.length);
                const wave = audioContext.createPeriodicWave(real, imag);
                osc1.setPeriodicWave(wave);
                osc2.setPeriodicWave(wave);
                osc3.setPeriodicWave(wave);
            } else {
                osc1.type = currentWaveform;
                osc2.type = currentWaveform;
                osc3.type = currentWaveform;
            }
            
            osc1.frequency.value = bendedFrequency;
            osc2.frequency.value = bendedFrequency * 0.995;
            osc3.frequency.value = bendedFrequency * 1.005;
            
            const envelope = audioContext.createGain();
            envelope.gain.value = 0;
            envelope.gain.setValueAtTime(0, now);
            envelope.gain.linearRampToValueAtTime(0.3, now + 0.02);
            envelope.gain.linearRampToValueAtTime(0.2, now + 0.15);
            
            const oscGain1 = audioContext.createGain();
            const oscGain2 = audioContext.createGain();
            const oscGain3 = audioContext.createGain();
            
            oscGain1.gain.value = 0.4;
            oscGain2.gain.value = 0.3;
            oscGain3.gain.value = 0.3;
            
            osc1.connect(oscGain1);
            osc2.connect(oscGain2);
            osc3.connect(oscGain3);
            
            oscGain1.connect(envelope);
            oscGain2.connect(envelope);
            oscGain3.connect(envelope);
            
            envelope.connect(filterNode);
            envelope.connect(delayNode);
            
            osc1.start(now);
            osc2.start(now);
            osc3.start(now);
            
            activeNotes.set(noteName, { osc1, osc2, osc3, envelope, baseFrequency: frequency });
            
            animateVisualizer();
            updateNoteDisplay(noteName);
            
            return { osc1, osc2, osc3, envelope };
        }

        function stopNote(noteName) {
            if (activeNotes.has(noteName)) {
                const noteData = activeNotes.get(noteName);
                const now = audioContext.currentTime;
                
                noteData.envelope.gain.cancelScheduledValues(now);
                noteData.envelope.gain.setValueAtTime(noteData.envelope.gain.value, now);
                noteData.envelope.gain.linearRampToValueAtTime(0, now + 0.3);
                
                setTimeout(() => {
                    if (noteData.noise) {
                        noteData.noise.stop();
                    } else if (noteData.osc1) {
                        noteData.osc1.stop();
                        noteData.osc2.stop();
                        noteData.osc3.stop();
                    }
                }, 400);
                
                activeNotes.delete(noteName);
            }
        }

        function playDrum(type) {
            initAudio();
            
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'kick':
                    const kickOsc = audioContext.createOscillator();
                    const kickGain = audioContext.createGain();
                    kickOsc.frequency.value = 150;
                    kickOsc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    kickGain.gain.value = 1 * drumVolumes.kick;
                    kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    kickOsc.type = 'sine';
                    kickOsc.connect(kickGain);
                    kickGain.connect(drumGain);
                    kickOsc.start(now);
                    kickOsc.stop(now + 0.5);
                    break;
                    
                case 'snare':
                    const snareOsc = audioContext.createOscillator();
                    const snareGain = audioContext.createGain();
                    const snareNoise = createNoiseSource();
                    const snareNoiseGain = audioContext.createGain();
                    
                    snareOsc.frequency.value = 200;
                    snareOsc.type = 'triangle';
                    snareGain.gain.value = 0.3 * drumVolumes.snare;
                    snareGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    
                    snareNoiseGain.gain.value = 0.4 * drumVolumes.snare;
                    snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    
                    snareOsc.connect(snareGain);
                    snareNoise.connect(snareNoiseGain);
                    snareGain.connect(drumGain);
                    snareNoiseGain.connect(drumGain);
                    
                    snareOsc.start(now);
                    snareNoise.start(now);
                    snareOsc.stop(now + 0.2);
                    snareNoise.stop(now + 0.15);
                    break;
                    
                case 'hihat':
                    const hihatNoise = createNoiseSource();
                    const hihatFilter = audioContext.createBiquadFilter();
                    const hihatGain = audioContext.createGain();
                    
                    hihatFilter.type = 'highpass';
                    hihatFilter.frequency.value = 7000;
                    hihatGain.gain.value = 0.3 * drumVolumes.hihat;
                    hihatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    
                    hihatNoise.connect(hihatFilter);
                    hihatFilter.connect(hihatGain);
                    hihatGain.connect(drumGain);
                    
                    hihatNoise.start(now);
                    hihatNoise.stop(now + 0.05);
                    break;
                    
                case 'clap':
                    // Create smoother, more natural clap sound
                    for (let i = 0; i < 7; i++) {
                        setTimeout(() => {
                            const clapNoise = createNoiseSource();
                            const clapFilter = audioContext.createBiquadFilter();
                            const clapGain = audioContext.createGain();
                            const clapTime = audioContext.currentTime;
                            
                            clapFilter.type = 'bandpass';
                            clapFilter.frequency.value = 1200;
                            clapFilter.Q.value = 1.5;
                            
                            // Smooth volume curve - builds up and fades
                            let burstVolume;
                            if (i < 3) {
                                burstVolume = 0.3 + (i * 0.15); // Build up
                            } else {
                                burstVolume = 0.75 - ((i - 3) * 0.1); // Fade out
                            }
                            
                            clapGain.gain.value = burstVolume * drumVolumes.clap;
                            clapGain.gain.linearRampToValueAtTime(0.01, clapTime + 0.06);
                            
                            clapNoise.connect(clapFilter);
                            clapFilter.connect(clapGain);
                            clapGain.connect(drumGain);
                            
                            clapNoise.start(clapTime);
                            clapNoise.stop(clapTime + 0.06);
                        }, i * 20);
                    }
                    break;
                    
                case 'tom1':
                    const tom1Osc = audioContext.createOscillator();
                    const tom1Gain = audioContext.createGain();
                    tom1Osc.frequency.value = 180;
                    tom1Osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                    tom1Gain.gain.value = 0.8 * drumVolumes.tom1;
                    tom1Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    tom1Osc.connect(tom1Gain);
                    tom1Gain.connect(drumGain);
                    tom1Osc.start(now);
                    tom1Osc.stop(now + 0.3);
                    break;
                    
                case 'tom2':
                    const tom2Osc = audioContext.createOscillator();
                    const tom2Gain = audioContext.createGain();
                    tom2Osc.frequency.value = 120;
                    tom2Osc.frequency.exponentialRampToValueAtTime(60, now + 0.2);
                    tom2Gain.gain.value = 0.8 * drumVolumes.tom2;
                    tom2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    tom2Osc.connect(tom2Gain);
                    tom2Gain.connect(drumGain);
                    tom2Osc.start(now);
                    tom2Osc.stop(now + 0.3);
                    break;
                    
                case 'cymbal':
                    const cymbalNoise = createNoiseSource();
                    const cymbalFilter = audioContext.createBiquadFilter();
                    const cymbalGain = audioContext.createGain();
                    
                    cymbalFilter.type = 'highpass';
                    cymbalFilter.frequency.value = 5000;
                    cymbalGain.gain.value = 0.4 * drumVolumes.cymbal;
                    cymbalGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    
                    cymbalNoise.connect(cymbalFilter);
                    cymbalFilter.connect(cymbalGain);
                    cymbalGain.connect(drumGain);
                    
                    cymbalNoise.start(now);
                    cymbalNoise.stop(now + 0.5);
                    break;
                    
                case 'perc':
                    const percOsc = audioContext.createOscillator();
                    const percGain = audioContext.createGain();
                    percOsc.frequency.value = 800;
                    percGain.gain.value = 0.3 * drumVolumes.perc;
                    percGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    percOsc.type = 'triangle';
                    percOsc.connect(percGain);
                    percGain.connect(drumGain);
                    percOsc.start(now);
                    percOsc.stop(now + 0.1);
                    break;
                    
                case 'shaker':
                    // Shaker - short burst of filtered noise
                    const shakerNoise = createNoiseSource();
                    const shakerFilter = audioContext.createBiquadFilter();
                    const shakerGain = audioContext.createGain();
                    
                    shakerFilter.type = 'highpass';
                    shakerFilter.frequency.value = 4000;
                    shakerFilter.Q.value = 2;
                    shakerGain.gain.value = 0.25 * drumVolumes.shaker;
                    shakerGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    
                    shakerNoise.connect(shakerFilter);
                    shakerFilter.connect(shakerGain);
                    shakerGain.connect(drumGain);
                    
                    shakerNoise.start(now);
                    shakerNoise.stop(now + 0.08);
                    break;
            }
            
            animateVisualizer();
        }

        function createNoiseSource() {
            const bufferSize = audioContext.sampleRate * 0.1;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            return noise;
        }

        // MIDI Support
        async function initMIDI() {
            if (navigator.requestMIDIAccess) {
                try {
                    midiAccess = await navigator.requestMIDIAccess();
                    console.log('MIDI Access granted');
                    
                    // Get all MIDI inputs
                    midiInputs = Array.from(midiAccess.inputs.values());
                    
                    if (midiInputs.length > 0) {
                        console.log(`Found ${midiInputs.length} MIDI input(s):`);
                        midiInputs.forEach((input, index) => {
                            console.log(`  ${index}: ${input.name}`);
                            input.onmidimessage = handleMIDIMessage;
                        });
                        
                        // Show notification to user
                        updateNoteDisplay('MIDI CONNECTED');
                        setTimeout(() => updateNoteDisplay('---'), 2000);
                    } else {
                        console.log('No MIDI inputs found. Connect a MIDI keyboard and refresh the page.');
                    }
                    
                    // Listen for device connection changes
                    midiAccess.onstatechange = (e) => {
                        if (e.port.type === 'input') {
                            if (e.port.state === 'connected') {
                                console.log(`MIDI device connected: ${e.port.name}`);
                                e.port.onmidimessage = handleMIDIMessage;
                                updateNoteDisplay('MIDI CONNECTED');
                                setTimeout(() => updateNoteDisplay('---'), 2000);
                            } else if (e.port.state === 'disconnected') {
                                console.log(`MIDI device disconnected: ${e.port.name}`);
                            }
                        }
                    };
                } catch (err) {
                    console.error('Failed to get MIDI access:', err);
                }
            } else {
                console.log('Web MIDI API not supported in this browser.');
            }
        }

        function handleMIDIMessage(message) {
            initAudio(); // Ensure audio context is initialized
            
            const [status, note, velocity] = message.data;
            const command = status >> 4;
            const channel = status & 0xf;
            
            // Note On (9) with velocity > 0
            if (command === 9 && velocity > 0) {
                const frequency = midiNoteToFrequency(note);
                const noteName = midiNoteToName(note);
                
                console.log('MIDI Note On:', noteName, 'arpEnabled:', arpEnabled);
                
                if (arpEnabled) {
                    console.log('Adding note to arp:', noteName);
                    arpNotes.push({ frequency, noteName });
                    console.log('Arp notes now:', arpNotes.length, 'interval:', arpInterval);
                    
                    // Start arp if not already running
                    if (!arpInterval) {
                        console.log('Starting arp...');
                        startArp();
                    }
                } else {
                    playNote(frequency, noteName);
                }
                
                // Animate the corresponding key if it exists on screen
                animateKeyForMIDI(noteName, true);
            }
            // Note Off (8) or Note On with velocity 0
            else if (command === 8 || (command === 9 && velocity === 0)) {
                const noteName = midiNoteToName(note);
                
                if (!arpEnabled) {
                    stopNote(noteName);
                }
                
                // Remove animation from the key
                animateKeyForMIDI(noteName, false);
            }
            // Pitch Bend (14)
            else if (command === 14) {
                // MIDI pitch bend is 14-bit (0-16383, center at 8192)
                const bendValue = (note | (velocity << 7)) - 8192;
                // Convert to -1 to 1 range
                pitchBendValue = bendValue / 8192;
                
                // Update pitch bend thumb position
                const pitchBendThumb = document.getElementById('pitchBendThumb');
                const pitchBend = document.getElementById('pitchBend');
                const range = 100 - 25; // height - thumb height
                const centerPos = range / 2;
                const newPos = centerPos - (pitchBendValue * centerPos);
                pitchBendThumb.style.top = newPos + 'px';
                
                // Update all active notes
                activeNotes.forEach((noteData, noteName) => {
                    const baseFreq = noteData.baseFrequency;
                    const bendedFreq = baseFreq * Math.pow(2, (pitchBendValue * 2) / 12);
                    
                    if (noteData.osc1 && noteData.osc1.frequency) {
                        noteData.osc1.frequency.setValueAtTime(bendedFreq, audioContext.currentTime);
                        noteData.osc2.frequency.setValueAtTime(bendedFreq * 0.995, audioContext.currentTime);
                        noteData.osc3.frequency.setValueAtTime(bendedFreq * 1.005, audioContext.currentTime);
                    } else if (noteData.noiseFilter && noteData.noiseFilter.frequency) {
                        noteData.noiseFilter.frequency.setValueAtTime(bendedFreq, audioContext.currentTime);
                    }
                });
            }
            // Control Change (11)
            else if (command === 11) {
                // CC 1 = Modulation Wheel
                // CC 7 = Volume
                // CC 64 = Sustain Pedal
                // You can add more CC mappings here
            }
        }

        function midiNoteToFrequency(midiNote) {
            // MIDI note 69 = A4 = 440 Hz
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }

        function midiNoteToName(midiNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteName = noteNames[midiNote % 12];
            return noteName + octave;
        }

        function animateKeyForMIDI(noteName, isPressed) {
            // Find the key element with this note name
            const keys = document.querySelectorAll('.white-key, .black-key');
            keys.forEach(key => {
                if (key.dataset.noteName === noteName) {
                    if (isPressed) {
                        key.classList.add('playing');
                    } else {
                        key.classList.remove('playing');
                    }
                }
            });
        }

        function clearAllMIDINotes() {
            // Stop all active notes
            const notesToStop = Array.from(activeNotes.keys());
            notesToStop.forEach(noteName => {
                stopNote(noteName);
            });
            
            // Stop arpeggiator if playing
            if (arpInterval) {
                clearInterval(arpInterval);
                arpInterval = null;
            }
            
            // Clear arp notes
            arpNotes = [];
            arpIndex = 0;
            
            // Remove all playing animations from keys
            const keys = document.querySelectorAll('.white-key, .black-key');
            keys.forEach(key => {
                key.classList.remove('playing');
            });
            
            // Reset pitch bend to center
            pitchBendValue = 0;
            const pitchBendThumb = document.getElementById('pitchBendThumb');
            if (pitchBendThumb) {
                pitchBendThumb.style.top = '37.5px';
            }
            
            // Turn off pitch hold
            pitchHoldEnabled = false;
            const pitchHoldBtn = document.getElementById('pitchHoldBtn');
            if (pitchHoldBtn) {
                pitchHoldBtn.classList.remove('active');
            }
            
            // Clear active notes map
            activeNotes.clear();
            
            // Show feedback
            updateNoteDisplay('MIDI CLEARED');
            setTimeout(() => updateNoteDisplay('---'), 1000);
        }

        // Save and Load Settings
        // Preset Management
        function savePreset(slot) {
            const presetData = {
                currentOctave: currentOctave,
                currentWaveform: currentWaveform,
                arpEnabled: arpEnabled,
                arpMode: arpMode,
                arpNotes: [...arpNotes],
                syncEnabled: syncEnabled,
                pitchHoldEnabled: pitchHoldEnabled,
                tempo: tempo,
                drumVolumes: {...drumVolumes},
                sequencerPattern: JSON.parse(JSON.stringify(sequencerPattern)),
                knobValues: {
                    delay: parseInt(document.getElementById('delayKnob').dataset.value),
                    feedback: parseInt(document.getElementById('feedbackKnob').dataset.value),
                    filter: parseInt(document.getElementById('filterKnob').dataset.value),
                    resonance: parseInt(document.getElementById('resonanceKnob').dataset.value),
                    synthVolume: parseInt(document.getElementById('synthVolumeKnob').dataset.value),
                    drumVolume: parseInt(document.getElementById('drumVolumeKnob').dataset.value),
                    masterVolume: parseInt(document.getElementById('masterVolumeKnob').dataset.value)
                }
            };
            
            presets[slot] = presetData;
            
            // Save to localStorage
            try {
                localStorage.setItem('dPaulMKIII_presets', JSON.stringify(presets));
                updateNoteDisplay(`M${slot} SAVED`);
                setTimeout(() => updateNoteDisplay('---'), 1000);
            } catch (e) {
                console.error('Failed to save preset:', e);
                updateNoteDisplay('SAVE FAIL');
                setTimeout(() => updateNoteDisplay('---'), 1000);
            }
        }

        function loadPreset(slot) {
            const presetData = presets[slot];
            
            if (!presetData) {
                updateNoteDisplay(`M${slot} EMPTY`);
                setTimeout(() => updateNoteDisplay('---'), 1000);
                return;
            }
            
            // Apply octave
            currentOctave = presetData.currentOctave;
            updateOctaveDisplay();
            rebuildKeyboard();
            
            // Apply waveform
            if (presetData.currentWaveform) {
                currentWaveform = presetData.currentWaveform;
                // Update waveform button visual
                document.querySelectorAll('.waveform-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === currentWaveform) {
                        btn.classList.add('active');
                    }
                });
            }
            
            // Apply tempo
            tempo = presetData.tempo;
            updateTempoDisplay();
            
            // Apply knob values
            Object.keys(presetData.knobValues).forEach(knobName => {
                const knob = document.getElementById(knobName + 'Knob');
                if (knob) {
                    knob.dataset.value = presetData.knobValues[knobName];
                    updateKnob(knob);
                }
            });
            
            // Apply drum volumes
            if (presetData.drumVolumes) {
                drumVolumes = presetData.drumVolumes;
                // Update volume dot visuals
                Object.keys(drumVolumes).forEach(drumName => {
                    const level = drumVolumes[drumName];
                    const dots = document.querySelectorAll(`.volume-dot[data-drum="${drumName}"]`);
                    dots.forEach(dot => {
                        dot.classList.remove('active');
                        if (parseFloat(dot.dataset.level) === level) {
                            dot.classList.add('active');
                        }
                    });
                });
            }
            
            // Apply sequencer pattern
            if (presetData.sequencerPattern) {
                sequencerPattern = presetData.sequencerPattern;
                updateSequencerDisplay();
            }
            
            // Apply sync
            syncEnabled = presetData.syncEnabled;
            const syncBtn = document.getElementById('syncBtn');
            if (syncEnabled) {
                syncBtn.classList.add('active');
            } else {
                syncBtn.classList.remove('active');
            }
            
            // Apply pitch hold
            pitchHoldEnabled = presetData.pitchHoldEnabled || false;
            const pitchHoldBtn = document.getElementById('pitchHoldBtn');
            if (pitchHoldEnabled) {
                pitchHoldBtn.classList.add('active');
            } else {
                pitchHoldBtn.classList.remove('active');
            }
            
            // Apply arp state
            arpEnabled = presetData.arpEnabled;
            if (presetData.arpMode) {
                arpMode = presetData.arpMode;
                // Update arp mode button visuals
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === arpMode) {
                        btn.classList.add('active');
                    }
                });
            }
            const arpSwitch = document.getElementById('arpSwitch');
            const arpLight = document.getElementById('arpLight');
            if (arpEnabled) {
                arpSwitch.classList.add('active');
                arpLight.classList.add('active');
            } else {
                arpSwitch.classList.remove('active');
                arpLight.classList.remove('active');
            }
            
            // Restart sequencer if it was playing
            if (sequencerPlaying) {
                stopSequencer();
                startSequencer();
            }
            
            updateNoteDisplay(`M${slot} LOAD`);
            setTimeout(() => updateNoteDisplay('---'), 1000);
        }

        function loadPresetsFromStorage() {
            try {
                const saved = localStorage.getItem('dPaulMKIII_presets');
                if (saved) {
                    presets = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load presets:', e);
            }
        }

        function saveSettings() {
            const settings = {
                // Synth settings
                volume: masterGain ? masterGain.gain.value : 0.7,
                drumVolume: drumGain ? drumGain.gain.value : 0.7,
                delay: delayNode ? delayNode.delayTime.value : 0.3,
                feedback: feedbackGain ? feedbackGain.gain.value : 0.3,
                filter: filterNode ? filterNode.frequency.value : 2000,
                resonance: filterNode ? filterNode.Q.value : 1,
                currentOctave: currentOctave,
                currentWaveform: currentWaveform,
                arpEnabled: arpEnabled,
                syncEnabled: syncEnabled,
                pitchHoldEnabled: pitchHoldEnabled,
                synthPowered: synthPowered,
                tempo: tempo,
                
                // Drum volumes
                drumVolumes: drumVolumes,
                
                // Sequencer pattern
                sequencerPattern: sequencerPattern
            };
            
            try {
                localStorage.setItem('dPaulMKIII_settings', JSON.stringify(settings));
                updateNoteDisplay('SAVED');
                setTimeout(() => updateNoteDisplay('---'), 1000);
                return true;
            } catch (e) {
                console.error('Failed to save settings:', e);
                updateNoteDisplay('SAVE FAILED');
                setTimeout(() => updateNoteDisplay('---'), 1000);
                return false;
            }
        }

        function loadSettings() {
            try {
                const saved = localStorage.getItem('dPaulMKIII_settings');
                if (!saved) return false;
                
                const settings = JSON.parse(saved);
                
                // Apply synth settings
                if (masterGain) masterGain.gain.value = settings.volume || 0.7;
                if (drumGain) drumGain.gain.value = settings.drumVolume || 0.7;
                if (delayNode) delayNode.delayTime.value = settings.delay || 0.3;
                if (feedbackGain) feedbackGain.gain.value = settings.feedback || 0.3;
                if (filterNode) {
                    filterNode.frequency.value = settings.filter || 2000;
                    filterNode.Q.value = settings.resonance || 1;
                }
                
                currentOctave = settings.currentOctave || 4;
                arpEnabled = settings.arpEnabled || false;
                syncEnabled = settings.syncEnabled || false;
                pitchHoldEnabled = settings.pitchHoldEnabled || false;
                
                // Update pitch hold button visual
                if (pitchHoldEnabled) {
                    document.getElementById('pitchHoldBtn').classList.add('active');
                } else {
                    document.getElementById('pitchHoldBtn').classList.remove('active');
                }
                
                tempo = settings.tempo || 120;
                
                // Apply waveform
                if (settings.currentWaveform) {
                    currentWaveform = settings.currentWaveform;
                    // Update waveform button visual
                    document.querySelectorAll('.waveform-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.wave === currentWaveform) {
                            btn.classList.add('active');
                        }
                    });
                }
                
                // Apply drum volumes
                if (settings.drumVolumes) {
                    drumVolumes = settings.drumVolumes;
                    
                    // Update volume dot visuals
                    Object.keys(drumVolumes).forEach(drumName => {
                        const level = drumVolumes[drumName];
                        const dots = document.querySelectorAll(`.volume-dot[data-drum="${drumName}"]`);
                        dots.forEach(dot => {
                            dot.classList.remove('active');
                            if (parseFloat(dot.dataset.level) === level) {
                                dot.classList.add('active');
                            }
                        });
                    });
                }
                
                // Apply sequencer pattern
                if (settings.sequencerPattern) {
                    sequencerPattern = settings.sequencerPattern;
                    updateSequencerDisplay();
                }
                
                // Update UI
                updateOctaveDisplay();
                updateTempoDisplay();
                
                // Update knobs
                document.getElementById('volumeKnob').dataset.value = Math.round(settings.volume * 100);
                document.getElementById('drumVolumeKnob').dataset.value = Math.round(settings.drumVolume * 100);
                
                // Update ARP and SYNC switches
                // Reset arp to off on page load to prevent confusion
                // User can turn it back on manually
                arpEnabled = false;
                document.getElementById('arpSwitch').classList.remove('active');
                document.getElementById('arpLight').classList.remove('active');
                
                if (syncEnabled) {
                    document.getElementById('syncBtn').classList.add('active');
                } else {
                    document.getElementById('syncBtn').classList.remove('active');
                }
                
                // Apply power state
                synthPowered = settings.synthPowered !== false; // Default to true
                const powerBtn = document.getElementById('powerBtn');
                const synthContainer = document.getElementById('synthContainer');
                if (synthPowered) {
                    powerBtn.classList.add('on');
                    powerBtn.textContent = 'ON';
                    synthContainer.classList.remove('powered-off');
                    synthContainer.classList.add('powered-on');
                } else {
                    powerBtn.classList.remove('on');
                    powerBtn.textContent = 'OFF';
                    synthContainer.classList.remove('powered-on');
                    synthContainer.classList.add('powered-off');
                }
                
                document.querySelectorAll('.knob').forEach(updateKnob);
                
                updateNoteDisplay('LOADED');
                setTimeout(() => updateNoteDisplay('---'), 1000);
                return true;
            } catch (e) {
                console.error('Failed to load settings:', e);
                return false;
            }
        }

        // Auto-save on changes
        function autoSave() {
            saveSettings();
        }

        // Kraftwerk-style synth sounds
        // Build keyboard with proper piano layout
        function buildKeyboard() {
            console.log('buildKeyboard called');
            const container = document.getElementById('pianoKeys');
            console.log('pianoKeys container:', container);
            if (!container) {
                console.error('pianoKeys container not found!');
                return;
            }
            container.innerHTML = '';
            
            // 37 keys = 3 full octaves + 1 note (C to C)
            // Pattern: C D E F G A B (white keys per octave)
            // Black keys appear after: C, D, F, G, A
            
            const blackKeyOffsets = {
                0: 17,   // C# after C (26 - 18/2 = 17)
                1: 43,   // D# after D (26*2 - 26 - 18/2 = 43)
                3: 95,   // F# after F
                4: 121,  // G# after G
                5: 147   // A# after A
            };
            
            let whiteKeyIndex = 0;
            let keysCreated = 0;
            
            for (let i = 0; i < 37; i++) {
                const noteIndex = i % 12;
                const octaveOffset = Math.floor(i / 12);
                const noteName = noteNames[noteIndex] + (currentOctave + octaveOffset);
                const isBlack = noteNames[noteIndex].includes('#');
                
                if (!isBlack) {
                    const key = document.createElement('div');
                    key.className = 'white-key';
                    key.dataset.note = i;
                    key.dataset.noteName = noteName;
                    
                    key.addEventListener('mousedown', () => handleKeyPress(key));
                    key.addEventListener('mouseup', () => handleKeyRelease(key));
                    key.addEventListener('mouseleave', () => handleKeyRelease(key));
                    key.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleKeyPress(key);
                    });
                    key.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handleKeyRelease(key);
                    });
                    
                    container.appendChild(key);
                    
                    // Add black key if needed (and if not the last key)
                    const whiteKeyInOctave = whiteKeyIndex % 7;
                    const nextNoteIndex = (i + 1) % 12;
                    const nextIsBlack = noteNames[nextNoteIndex] && noteNames[nextNoteIndex].includes('#');
                    
                    if (blackKeyOffsets[whiteKeyInOctave] !== undefined && i < 36 && nextIsBlack) {
                        const blackKey = document.createElement('div');
                        blackKey.className = 'black-key';
                        blackKey.dataset.note = i + 1;
                        blackKey.dataset.noteName = noteNames[nextNoteIndex] + (currentOctave + Math.floor((i + 1) / 12));
                        blackKey.style.left = blackKeyOffsets[whiteKeyInOctave] + (Math.floor(whiteKeyIndex / 7) * 182) + 'px'; // 7 white keys * 26px = 182px per octave
                        
                        blackKey.addEventListener('mousedown', () => handleKeyPress(blackKey));
                        blackKey.addEventListener('mouseup', () => handleKeyRelease(blackKey));
                        blackKey.addEventListener('mouseleave', () => handleKeyRelease(blackKey));
                        blackKey.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            handleKeyPress(blackKey);
                        });
                        blackKey.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            handleKeyRelease(blackKey);
                        });
                        
                        container.appendChild(blackKey);
                        keysCreated++;
                    }
                    
                    whiteKeyIndex++;
                    keysCreated++;
                }
            }
            console.log('buildKeyboard completed:', keysCreated, 'keys created');
            console.log('Container children:', container.children.length);
        }

        function handleKeyPress(key) {
            if (key.classList.contains('playing')) return;
            
            key.classList.add('playing');
            const noteIndex = parseInt(key.dataset.note);
            const noteName = key.dataset.noteName;
            const frequency = getNoteFrequency(noteIndex, currentOctave);
            
            if (arpEnabled) {
                arpNotes.push({ frequency, noteName });
                
                // Start arp if not already running
                if (!arpInterval) {
                    startArp();
                }
            } else {
                playNote(frequency, noteName);
            }
        }

        function handleKeyRelease(key) {
            key.classList.remove('playing');
            const noteName = key.dataset.noteName;
            
            if (!arpEnabled) {
                stopNote(noteName);
            }
        }

        function toggleArp() {
            arpEnabled = !arpEnabled;
            const arpSwitch = document.getElementById('arpSwitch');
            const arpLight = document.getElementById('arpLight');
            
            if (arpEnabled) {
                arpSwitch.classList.add('active');
                arpLight.classList.add('active');
                
                // Don't start arp here - it will start when first note is added
                // Only start if there are already notes (e.g., loading from preset)
                if (arpNotes.length > 0) {
                    startArp();
                }
                
                // Start sequencer if sync is enabled
                if (syncEnabled && !sequencerPlaying) {
                    startSequencer();
                }
            } else {
                arpSwitch.classList.remove('active');
                arpLight.classList.remove('active');
                
                // Force stop the arp interval
                if (arpInterval) {
                    clearInterval(arpInterval);
                    arpInterval = null;
                }
                
                // Clear arp notes and state
                stopArp();
                
                // Stop sequencer if sync is enabled
                if (syncEnabled && sequencerPlaying) {
                    stopSequencer();
                }
            }
            autoSave();
        }

        function startArp() {
            // Don't start if no notes
            if (arpNotes.length === 0) {
                console.log('startArp: No notes, not starting');
                return;
            }
            
            console.log('startArp: Starting with', arpNotes.length, 'notes, mode:', arpMode);
            
            // Clear any existing interval first
            if (arpInterval) {
                clearInterval(arpInterval);
                arpInterval = null;
            }
            
            const stepTime = (60 / tempo) * 1000 / 4; // 16th notes - same as sequencer
            console.log('startArp: Step time =', stepTime, 'ms');
            
            arpInterval = setInterval(() => {
                if (arpNotes.length > 0) {
                    let noteIndex;
                    
                    switch(arpMode) {
                        case 'up':
                            noteIndex = arpIndex % arpNotes.length;
                            break;
                            
                        case 'down':
                            noteIndex = (arpNotes.length - 1) - (arpIndex % arpNotes.length);
                            break;
                            
                        case 'updown':
                            const cycle = (arpNotes.length * 2) - 2;
                            const pos = arpIndex % cycle;
                            if (pos < arpNotes.length) {
                                noteIndex = pos;
                            } else {
                                noteIndex = (arpNotes.length * 2 - 2) - pos;
                            }
                            break;
                            
                        case 'random':
                            noteIndex = Math.floor(Math.random() * arpNotes.length);
                            break;
                            
                        default:
                            noteIndex = arpIndex % arpNotes.length;
                    }
                    
                    const note = arpNotes[noteIndex];
                    console.log('Arp playing:', note.noteName, 'mode:', arpMode);
                    playNote(note.frequency, note.noteName);
                    setTimeout(() => stopNote(note.noteName), stepTime * 0.75); // 75% of step time
                    arpIndex++;
                } else {
                    // No notes left, stop the arp
                    console.log('Arp stopped: no notes');
                    if (arpInterval) {
                        clearInterval(arpInterval);
                        arpInterval = null;
                    }
                }
            }, stepTime);
            
            console.log('startArp: Interval started, ID =', arpInterval);
        }

        function stopArp() {
            if (arpInterval) {
                clearInterval(arpInterval);
                arpInterval = null;
            }
            arpNotes = [];
            arpIndex = 0;
        }

        function pauseArp() {
            // Just stop the interval, don't clear notes
            if (arpInterval) {
                clearInterval(arpInterval);
                arpInterval = null;
            }
        }

        function syncRestart() {
            // Restart both arp and sequencer in sync
            const wasArpPlaying = arpEnabled && arpInterval;
            const wasSeqPlaying = sequencerPlaying;
            
            // Stop both
            if (wasArpPlaying) pauseArp();
            if (wasSeqPlaying) stopSequencer();
            
            // Reset indices to sync them
            arpIndex = 0;
            currentStep = 0;
            
            // Restart both simultaneously
            if (wasArpPlaying) startArp();
            if (wasSeqPlaying) startSequencer();
        }

        function setupKnobs() {
            const knobs = document.querySelectorAll('.knob');
            
            knobs.forEach(knob => {
                let isDragging = false;
                let startY = 0;
                let startValue = parseInt(knob.dataset.value);
                
                knob.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = parseInt(knob.dataset.value);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const delta = startY - e.clientY;
                    let newValue = startValue + delta;
                    newValue = Math.max(0, Math.min(100, newValue));
                    
                    knob.dataset.value = newValue;
                    updateKnob(knob);
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        autoSave(); // Save when knob is released
                    }
                });
            });
        }

        function updateKnob(knob) {
            const value = parseInt(knob.dataset.value);
            const rotation = (value / 100) * 270 - 135;
            knob.style.transform = `rotate(${rotation}deg)`;
            
            const valueDisplay = document.getElementById(knob.id.replace('Knob', 'Value'));
            if (valueDisplay) {
                valueDisplay.textContent = value + '%';
            }
            
            if (knob.id === 'delayKnob' && delayNode) {
                delayNode.delayTime.value = (value / 100) * 0.5;
            } else if (knob.id === 'feedbackKnob' && feedbackGain) {
                feedbackGain.gain.value = value / 100;
            } else if (knob.id === 'filterKnob' && filterNode) {
                filterNode.frequency.value = 200 + (value / 100) * 4800;
            } else if (knob.id === 'resonanceKnob' && filterNode) {
                filterNode.Q.value = 1 + (value / 100) * 19;
            } else if (knob.id === 'synthVolumeKnob' && synthGain) {
                synthGain.gain.value = value / 100;
            } else if (knob.id === 'drumVolumeKnob' && drumGain) {
                drumGain.gain.value = value / 100;
            } else if (knob.id === 'masterVolumeKnob' && masterGain) {
                masterGain.gain.value = value / 100;
            }
        }

        function animateVisualizer() {
            const visualizer = document.getElementById('visualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 40; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                bar.style.height = Math.random() * 40 + 'px';
                visualizer.appendChild(bar);
            }
            
            setTimeout(() => {
                visualizer.innerHTML = '';
            }, 300);
        }

        function updateNoteDisplay(note) {
            document.getElementById('noteDisplay').textContent = note;
        }

        document.getElementById('octaveUp').addEventListener('click', () => {
            if (currentOctave < 7) {
                currentOctave++;
                updateOctaveDisplay();
                rebuildKeyboard();
                autoSave();
            }
        });

        document.getElementById('octaveDown').addEventListener('click', () => {
            if (currentOctave > 1) {
                currentOctave--;
                updateOctaveDisplay();
                rebuildKeyboard();
                autoSave();
            }
        });

        // Clear MIDI button
        document.getElementById('clearMidiBtn').addEventListener('click', () => {
            clearAllMIDINotes();
        });

        function updateOctaveDisplay() {
            document.getElementById('octaveDisplay').textContent = `OCT ${currentOctave}`;
        }

        function rebuildKeyboard() {
            buildKeyboard();
        }

        document.querySelectorAll('.pad').forEach(pad => {
            pad.addEventListener('click', () => {
                // Deselect sample pads
                document.querySelectorAll('.sample-pad').forEach(sp => sp.classList.remove('selected'));
                selectedSample = null;
                
                // Select this drum for sequencing
                document.querySelectorAll('.pad').forEach(p => p.classList.remove('selected'));
                pad.classList.add('selected');
                selectedDrum = pad.dataset.sound;
                updateSequencerDisplay();
                
                // Play drum sound
                playDrum(pad.dataset.sound);
            });
        });

        // REMOVED - Sample pads S1-S10 removed from UI
        /*
        // Sample pads - play sample
        document.querySelectorAll('.sample-pad').forEach(samplePad => {
            samplePad.addEventListener('click', () => {
                const sampleNum = parseInt(samplePad.dataset.sample);
                
                // Deselect drum pads
                document.querySelectorAll('.pad').forEach(p => p.classList.remove('selected'));
                selectedDrum = null;
                
                // Select this sample for sequencing
                document.querySelectorAll('.sample-pad').forEach(sp => sp.classList.remove('selected'));
                samplePad.classList.add('selected');
                selectedSample = `sample${sampleNum}`;
                updateSequencerDisplay();
                
                // Play sample if loaded
                playSample(sampleNum);
            });
        });

        // Load sample buttons
        document.querySelectorAll('.load-sample-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const sampleNum = parseInt(btn.dataset.sample);
                document.getElementById(`sampleFile${sampleNum}`).click();
            });
        });

        // Clear sample buttons
        document.querySelectorAll('.clear-sample-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const sampleNum = parseInt(btn.dataset.sample);
                clearSample(sampleNum);
            });
        });

        function clearSample(sampleNum) {
            // Remove sample buffer
            delete sampleBuffers[sampleNum];
            
            // Remove loaded visual state
            const pad = document.querySelector(`.sample-pad[data-sample="${sampleNum}"]`);
            pad.classList.remove('loaded');
            
            // Clear file input
            document.getElementById(`sampleFile${sampleNum}`).value = '';
            
            // Clear sequencer pattern for this sample
            sequencerPattern[`sample${sampleNum}`] = Array(32).fill(false);
            
            // Deselect if this sample was selected
            if (selectedSample === `sample${sampleNum}`) {
                pad.classList.remove('selected');
                selectedSample = null;
                updateSequencerDisplay();
            }
            
            updateNoteDisplay(`S${sampleNum + 1} CLEARED`);
            setTimeout(() => updateNoteDisplay('---'), 1000);
        }

        // File input handlers
        for (let i = 0; i < 10; i++) {
            document.getElementById(`sampleFile${i}`).addEventListener('change', (e) => {
                loadSampleFile(i, e.target.files[0]);
            });
        }
        */

        // Load sample file
        function loadSampleFile(sampleNum, file) {
            if (!file) {
                console.log('No file selected');
                return;
            }
            
            console.log(`Loading sample ${sampleNum}: ${file.name}`);
            
            initAudio();
            const reader = new FileReader();
            
            reader.onerror = (error) => {
                console.error('FileReader error:', error);
                updateNoteDisplay('READ ERROR');
                setTimeout(() => updateNoteDisplay('---'), 1000);
            };
            
            reader.onload = (e) => {
                console.log(`File read complete for sample ${sampleNum}, decoding...`);
                
                // Create a copy of the array buffer
                const arrayBuffer = e.target.result.slice(0);
                
                audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                    console.log(`Sample ${sampleNum} decoded successfully`);
                    
                    // Store the buffer
                    sampleBuffers[sampleNum] = buffer;
                    
                    // Visual feedback - add green border
                    const pad = document.querySelector(`.sample-pad[data-sample="${sampleNum}"]`);
                    if (pad) {
                        pad.classList.add('loaded');
                        console.log(`Sample ${sampleNum} visual updated`);
                    }
                    
                    updateNoteDisplay(`S${sampleNum + 1} LOADED`);
                    setTimeout(() => updateNoteDisplay('---'), 1000);
                    
                    // Play sample immediately to confirm it loaded
                    playSample(sampleNum);
                    
                }, (error) => {
                    console.error('Error decoding audio:', error);
                    updateNoteDisplay('DECODE ERROR');
                    setTimeout(() => updateNoteDisplay('---'), 1000);
                });
            };
            
            reader.readAsArrayBuffer(file);
        }

        // Play sample
        function playSample(sampleNum) {
            console.log(`Attempting to play sample ${sampleNum}`);
            console.log(`Available samples:`, Object.keys(sampleBuffers));
            
            if (!sampleBuffers[sampleNum]) {
                console.log(`Sample ${sampleNum} not loaded`);
                return;
            }
            
            console.log(`Playing sample ${sampleNum}`);
            
            initAudio();
            let buffer = sampleBuffers[sampleNum];
            
            // Reverse if enabled
            if (sampleReverse) {
                buffer = reverseBuffer(buffer);
            }
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            
            // Apply pitch (detune in cents: semitones * 100)
            source.detune.value = samplePitch * 100;
            
            // Apply speed (playback rate)
            source.playbackRate.value = sampleSpeed;
            
            // Apply loop
            source.loop = sampleLoop;
            
            // Apply filter
            const sampleFilterNode = audioContext.createBiquadFilter();
            sampleFilterNode.type = 'lowpass';
            sampleFilterNode.frequency.value = sampleFilter;
            
            source.connect(sampleFilterNode);
            sampleFilterNode.connect(drumGain);
            source.start(audioContext.currentTime);
            
            animateVisualizer();
        }

        // Reverse audio buffer
        function reverseBuffer(buffer) {
            const reversed = audioContext.createBuffer(
                buffer.numberOfChannels,
                buffer.length,
                buffer.sampleRate
            );
            
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const inputData = buffer.getChannelData(channel);
                const outputData = reversed.getChannelData(channel);
                
                for (let i = 0; i < buffer.length; i++) {
                    outputData[i] = inputData[buffer.length - 1 - i];
                }
            }
            
            return reversed;
        }

        document.getElementById('arpSwitch').addEventListener('click', toggleArp);
        
        // Arp mode buttons
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                arpMode = btn.dataset.mode;
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Restart arp if it's playing to apply new mode
                if (arpEnabled && arpInterval) {
                    stopArp();
                    startArp();
                }
            });
        });

        // Sampler controls
        // setupSamplerKnobs(); // REMOVED - sampler controls removed from UI
        
        function setupSamplerKnobs() {
            // Pitch knob (-12 to +12 semitones)
            setupSamplerKnob('samplePitchKnob', -12, 12, (value) => {
                samplePitch = value;
                document.getElementById('samplePitchValue').textContent = (value > 0 ? '+' : '') + value;
            });
            
            // Speed knob (0.5x to 2.0x)
            setupSamplerKnob('sampleSpeedKnob', 0.5, 2.0, (value) => {
                sampleSpeed = value;
                document.getElementById('sampleSpeedValue').textContent = value.toFixed(1) + 'x';
            });
            
            // Filter knob (200Hz to 20kHz)
            setupSamplerKnob('sampleFilterKnob', 200, 20000, (value) => {
                sampleFilter = value;
                const displayValue = value >= 1000 ? (value / 1000).toFixed(1) + 'k' : value.toFixed(0);
                document.getElementById('sampleFilterValue').textContent = displayValue;
            });
        }
        
        function setupSamplerKnob(knobId, minVal, maxVal, callback) {
            const knob = document.getElementById(knobId);
            let isDragging = false;
            let startY = 0;
            let startValue = parseInt(knob.dataset.value);
            
            knob.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startValue = parseInt(knob.dataset.value);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || e.target.closest(`#${knobId}`) === null && !isDragging) return;
                if (!isDragging) return;
                
                const delta = startY - e.clientY;
                let newValue = startValue + delta;
                newValue = Math.max(0, Math.min(100, newValue));
                
                knob.dataset.value = newValue;
                const rotation = (newValue / 100) * 270 - 135;
                knob.style.transform = `rotate(${rotation}deg)`;
                
                // Map to actual value range
                const actualValue = minVal + (newValue / 100) * (maxVal - minVal);
                callback(actualValue);
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Initialize
            const rotation = (startValue / 100) * 270 - 135;
            knob.style.transform = `rotate(${rotation}deg)`;
            const initialValue = minVal + (startValue / 100) * (maxVal - minVal);
            callback(initialValue);
        }
        
        // Reverse switch - REMOVED (sampler controls removed from UI)
        /*
        document.getElementById('sampleReverseSwitch').addEventListener('click', () => {
            sampleReverse = !sampleReverse;
            const sw = document.getElementById('sampleReverseSwitch');
            if (sampleReverse) {
                sw.classList.add('active');
            } else {
                sw.classList.remove('active');
            }
        });
        */
        
        // Loop switch - REMOVED (sampler controls removed from UI)
        /*
        document.getElementById('sampleLoopSwitch').addEventListener('click', () => {
            sampleLoop = !sampleLoop;
            const sw = document.getElementById('sampleLoopSwitch');
            if (sampleLoop) {
                sw.classList.add('active');
            } else {
                sw.classList.remove('active');
            }
        });
        */


        // Waveform buttons
        document.querySelectorAll('.waveform-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all waveform buttons
                document.querySelectorAll('.waveform-btn').forEach(b => b.classList.remove('active'));
                // Add active to clicked button
                btn.classList.add('active');
                // Update current waveform
                currentWaveform = btn.dataset.wave;
                autoSave();
            });
        });

        // Clear arp button
        document.getElementById('clearArpBtn').addEventListener('click', () => {
            // Clear arp notes array
            arpNotes = [];
            arpIndex = 0;
            
            // Remove playing class from all keys
            document.querySelectorAll('.white-key, .black-key').forEach(key => {
                key.classList.remove('playing');
            });
            
            // If arp is playing, pause it (will restart when new notes added)
            if (arpInterval) {
                pauseArp();
            }
            
            // Visual feedback
            updateNoteDisplay('ARP CLEARED');
            setTimeout(() => updateNoteDisplay('---'), 1000);
        });

        // Initialize sequencer
        function initSequencer() {
            const grid = document.getElementById('sequencerGrid');
            
            for (let i = 0; i < 32; i++) {
                const step = document.createElement('div');
                step.className = 'step';
                step.dataset.step = i;
                
                const stepNum = document.createElement('div');
                stepNum.className = 'step-number';
                stepNum.textContent = i + 1;
                step.appendChild(stepNum);
                
                step.addEventListener('click', () => {
                    const activeTrack = selectedDrum || selectedSample;
                    if (activeTrack && sequencerPattern[activeTrack]) {
                        sequencerPattern[activeTrack][i] = !sequencerPattern[activeTrack][i];
                        updateSequencerDisplay();
                        autoSave();
                    }
                });
                
                grid.appendChild(step);
            }
            
            // Select kick by default
            document.querySelector('[data-sound="kick"]').classList.add('selected');
        }

        function updateSequencerDisplay() {
            const steps = document.querySelectorAll('.step');
            const activeTrack = selectedDrum || selectedSample;
            if (!activeTrack) return;
            
            steps.forEach((step, i) => {
                if (sequencerPattern[activeTrack] && sequencerPattern[activeTrack][i]) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }
            });
        }

        function startSequencer() {
            if (sequencerPlaying) return;
            
            sequencerPlaying = true;
            currentStep = 0;
            
            const stepTime = (60 / tempo) * 1000 / 4; // 16th notes
            let nextStepTime = Date.now();
            
            function step() {
                if (!sequencerPlaying) return;
                
                // Remove playing class from all steps
                document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
                
                // Add playing class to current step
                const stepElements = document.querySelectorAll('.step');
                stepElements[currentStep].classList.add('playing');
                
                // Flash BPM indicator on beat 1
                if (currentStep === 0 || currentStep === 4 || currentStep === 8 || currentStep === 12 || currentStep === 16 || currentStep === 20 || currentStep === 24 || currentStep === 28) {
                    const bpmLed = document.getElementById('bpmIndicator');
                    bpmLed.classList.add('beat');
                    setTimeout(() => bpmLed.classList.remove('beat'), 50);
                }
                
                // Play all active drums and samples on this step
                Object.keys(sequencerPattern).forEach(track => {
                    if (sequencerPattern[track][currentStep]) {
                        if (track.startsWith('sample')) {
                            // Play sample
                            const sampleNum = parseInt(track.replace('sample', ''));
                            playSample(sampleNum);
                        } else {
                            // Play drum
                            playDrum(track);
                        }
                    }
                });
                
                currentStep = (currentStep + 1) % sequencerSteps;
                
                // Schedule next step with accurate timing
                nextStepTime += stepTime;
                const delay = nextStepTime - Date.now();
                sequencerInterval = setTimeout(step, Math.max(0, delay));
            }
            
            step();
            document.getElementById('playSeq').classList.add('active');
        }

        function stopSequencer() {
            sequencerPlaying = false;
            if (sequencerInterval) {
                clearTimeout(sequencerInterval);
                sequencerInterval = null;
            }
            currentStep = 0;
            
            document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
            document.getElementById('playSeq').classList.remove('active');
        }

        function clearSequencer() {
            Object.keys(sequencerPattern).forEach(drum => {
                sequencerPattern[drum] = Array(32).fill(false);
            });
            updateSequencerDisplay();
            autoSave();
        }

        // Sequencer controls
        document.getElementById('playSeq').addEventListener('click', () => {
            if (sequencerPlaying) {
                stopSequencer();
            } else {
                startSequencer();
            }
        });

        document.getElementById('stopSeq').addEventListener('click', stopSequencer);
        document.getElementById('clearSeq').addEventListener('click', clearSequencer);

        // Step length selector
        document.getElementById('steps8Btn').addEventListener('click', () => setSequencerSteps(8));
        document.getElementById('steps16Btn').addEventListener('click', () => setSequencerSteps(16));
        document.getElementById('steps32Btn').addEventListener('click', () => setSequencerSteps(32));

        function setSequencerSteps(steps) {
            const wasPlaying = sequencerPlaying;
            if (wasPlaying) stopSequencer();
            
            sequencerSteps = steps;
            
            // Update button states
            document.querySelectorAll('[data-steps]').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-steps="${steps}"]`).classList.add('active');
            
            // Show/hide steps
            const stepElements = document.querySelectorAll('.step');
            stepElements.forEach((step, i) => {
                if (i < steps) {
                    step.classList.remove('hidden');
                } else {
                    step.classList.add('hidden');
                }
            });
            
            if (wasPlaying) startSequencer();
        }

        // Initialize step visibility on load
        setSequencerSteps(32);

        // Sync button
        document.getElementById('syncBtn').addEventListener('click', () => {
            syncEnabled = !syncEnabled;
            const syncBtn = document.getElementById('syncBtn');
            if (syncEnabled) {
                syncBtn.classList.add('active');
                // When sync is enabled and arp is playing, start sequencer
                if (arpEnabled && !sequencerPlaying) {
                    startSequencer();
                    // Re-sync both if arp is already playing
                    if (arpInterval) {
                        syncRestart();
                    }
                } else if (!arpEnabled && sequencerPlaying) {
                    stopSequencer();
                } else if (arpInterval && sequencerPlaying) {
                    // Both already playing - re-sync them
                    syncRestart();
                }
            } else {
                syncBtn.classList.remove('active');
            }
            autoSave();
        });

        // Drum volume knob
        const drumVolumeKnob = document.getElementById('drumVolumeKnob');
        let isDraggingDrumVolume = false;
        let drumVolumeStartY = 0;
        let drumVolumeStartValue = 70;

        drumVolumeKnob.addEventListener('mousedown', (e) => {
            isDraggingDrumVolume = true;
            drumVolumeStartY = e.clientY;
            drumVolumeStartValue = parseInt(drumVolumeKnob.dataset.value);
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingDrumVolume) return;
            
            const delta = drumVolumeStartY - e.clientY;
            let newValue = drumVolumeStartValue + delta;
            newValue = Math.max(0, Math.min(100, newValue));
            
            drumVolumeKnob.dataset.value = newValue;
            const rotation = (newValue / 100) * 270 - 135;
            drumVolumeKnob.style.transform = `rotate(${rotation}deg)`;
            
            document.getElementById('drumVolumeValue').textContent = newValue + '%';
            
            if (drumGain) {
                drumGain.gain.value = newValue / 100;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingDrumVolume) {
                isDraggingDrumVolume = false;
                autoSave();
            }
        });

        // Individual drum volume 3-dot switches
        document.querySelectorAll('.volume-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                const drumName = dot.dataset.drum;
                const level = parseFloat(dot.dataset.level);
                
                // Remove active class from all dots for this drum
                document.querySelectorAll(`.volume-dot[data-drum="${drumName}"]`).forEach(d => {
                    d.classList.remove('active');
                });
                
                // Add active class to clicked dot
                dot.classList.add('active');
                
                // Update drum volume
                drumVolumes[drumName] = level;
                autoSave();
            });
        });

        // Tempo control
        const tempoSlider = document.getElementById('tempoSlider');
        let isDraggingTempo = false;

        tempoSlider.addEventListener('mousedown', (e) => {
            isDraggingTempo = true;
            updateTempo(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingTempo) {
                updateTempo(e);
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingTempo = false;
        });

        function updateTempo(e) {
            const rect = tempoSlider.getBoundingClientRect();
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const percentage = x / rect.width;
            tempo = Math.round(60 + (percentage * 180)); // 60-240 BPM
            
            updateTempoDisplay();
            
            // Restart sequencer if playing to update tempo
            if (sequencerPlaying) {
                stopSequencer();
                startSequencer();
            }
        }

        function updateTempoDisplay() {
            const percentage = (tempo - 60) / 180;
            tempoSlider.style.setProperty('--tempo-width', (percentage * 100) + '%');
            document.getElementById('tempoValue').textContent = tempo + ' BPM';
            
            // Restart tempo LED blinking at new tempo
            startTempoLed();
        }

        function startTempoLed() {
            // Clear existing interval
            if (tempoLedInterval) {
                clearInterval(tempoLedInterval);
            }
            
            const tempoLed = document.getElementById('tempoLed');
            const beatInterval = (60 / tempo) * 1000; // One beat in milliseconds
            
            // Blink immediately
            tempoLed.classList.add('blink');
            setTimeout(() => tempoLed.classList.remove('blink'), 100);
            
            // Set up repeating blink
            tempoLedInterval = setInterval(() => {
                tempoLed.classList.add('blink');
                setTimeout(() => tempoLed.classList.remove('blink'), 100);
            }, beatInterval);
        }

        // Tempo up/down buttons
        document.getElementById('tempoUp').addEventListener('click', () => {
            tempo = Math.min(240, tempo + 5);
            updateTempoDisplay();
            
            // If sync is enabled and both are playing, restart in sync
            if (syncEnabled && sequencerPlaying && arpInterval) {
                syncRestart();
            } else {
                // Otherwise restart them independently
                if (sequencerPlaying) {
                    stopSequencer();
                    startSequencer();
                }
                
                if (arpEnabled && arpInterval) {
                    pauseArp();
                    startArp();
                }
            }
            autoSave();
        });

        document.getElementById('tempoDown').addEventListener('click', () => {
            tempo = Math.max(60, tempo - 5);
            updateTempoDisplay();
            
            // If sync is enabled and both are playing, restart in sync
            if (syncEnabled && sequencerPlaying && arpInterval) {
                syncRestart();
            } else {
                // Otherwise restart them independently
                if (sequencerPlaying) {
                    stopSequencer();
                    startSequencer();
                }
                
                if (arpEnabled && arpInterval) {
                    pauseArp();
                    startArp();
                }
            }
            autoSave();
        });

        // Initialize tempo slider
        updateTempoDisplay();

        // Pitch bend control
        const pitchBend = document.getElementById('pitchBend');
        const pitchBendThumb = document.getElementById('pitchBendThumb');
        let isDraggingPitch = false;

        pitchBendThumb.addEventListener('mousedown', (e) => {
            isDraggingPitch = true;
            e.stopPropagation();
        });

        pitchBend.addEventListener('mousedown', (e) => {
            if (e.target === pitchBend || e.target.classList.contains('pitch-bend-center')) {
                isDraggingPitch = true;
                updatePitchBend(e);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingPitch) {
                updatePitchBend(e);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingPitch) {
                isDraggingPitch = false;
                
                // Only snap back to center if hold is not enabled
                if (!pitchHoldEnabled) {
                    pitchBendValue = 0;
                    pitchBendThumb.style.top = '37.5px';
                    
                    // Update all active notes
                    activeNotes.forEach((noteData, noteName) => {
                        if (noteData.osc1 && noteData.osc1.frequency) {
                            const baseFreq = noteData.baseFrequency;
                            noteData.osc1.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                            noteData.osc2.frequency.setValueAtTime(baseFreq * 0.995, audioContext.currentTime);
                            noteData.osc3.frequency.setValueAtTime(baseFreq * 1.005, audioContext.currentTime);
                        }
                    });
                }
            }
        });

        function updatePitchBend(e) {
            const rect = pitchBend.getBoundingClientRect();
            const y = Math.max(0, Math.min(e.clientY - rect.top, rect.height - 25));
            pitchBendThumb.style.top = y + 'px';
            
            // Calculate bend value (-1 to 1)
            const center = (rect.height - 25) / 2;
            pitchBendValue = -(y - center) / center;
            
            // Update all active notes in real-time
            activeNotes.forEach((noteData, noteName) => {
                const baseFreq = noteData.baseFrequency;
                const bendedFreq = baseFreq * Math.pow(2, (pitchBendValue * 2) / 12);
                
                if (noteData.osc1 && noteData.osc1.frequency) {
                    noteData.osc1.frequency.setValueAtTime(bendedFreq, audioContext.currentTime);
                    noteData.osc2.frequency.setValueAtTime(bendedFreq * 0.995, audioContext.currentTime);
                    noteData.osc3.frequency.setValueAtTime(bendedFreq * 1.005, audioContext.currentTime);
                } else if (noteData.noiseFilter && noteData.noiseFilter.frequency) {
                    noteData.noiseFilter.frequency.setValueAtTime(bendedFreq, audioContext.currentTime);
                }
            });
        }

        // Wait for DOM to be ready before initializing
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Initializing synth...');
            
            buildKeyboard();
            setupKnobs();
            initSequencer();
            initMIDI(); // Initialize MIDI support
            
            // Load presets from storage
            loadPresetsFromStorage();
        
        // Preset button selection
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove selected class from all
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('selected'));
                // Add to clicked
                btn.classList.add('selected');
                selectedPreset = parseInt(btn.dataset.preset);
            });
        });
        
        // Set M1 as default selected
        document.getElementById('preset1').classList.add('selected');
        
        // Save preset button
        document.getElementById('savePreset').addEventListener('click', () => {
            savePreset(selectedPreset);
        });
        
        // Load preset button
        document.getElementById('loadPreset').addEventListener('click', () => {
            loadPreset(selectedPreset);
        });
        
        // Pitch hold button
        document.getElementById('pitchHoldBtn').addEventListener('click', () => {
            pitchHoldEnabled = !pitchHoldEnabled;
            const holdBtn = document.getElementById('pitchHoldBtn');
            
            if (pitchHoldEnabled) {
                holdBtn.classList.add('active');
            } else {
                holdBtn.classList.remove('active');
                // When disabling hold, snap back to center
                pitchBendValue = 0;
                document.getElementById('pitchBendThumb').style.top = '37.5px';
                
                // Update all active notes
                activeNotes.forEach((noteData, noteName) => {
                    if (noteData.osc1 && noteData.osc1.frequency) {
                        const baseFreq = noteData.baseFrequency;
                        noteData.osc1.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                        noteData.osc2.frequency.setValueAtTime(baseFreq * 0.995, audioContext.currentTime);
                        noteData.osc3.frequency.setValueAtTime(baseFreq * 1.005, audioContext.currentTime);
                    }
                });
            }
            autoSave();
        });
        
        // Power button
        document.getElementById('powerBtn').addEventListener('click', () => {
            synthPowered = !synthPowered;
            const powerBtn = document.getElementById('powerBtn');
            const synthContainer = document.getElementById('synthContainer');
            
            if (synthPowered) {
                // Power ON
                powerBtn.classList.add('on');
                powerBtn.textContent = 'ON';
                synthContainer.classList.remove('powered-off');
                synthContainer.classList.add('powered-on');
                
                // Restart tempo LED
                startTempoLed();
            } else {
                // Power OFF
                powerBtn.classList.remove('on');
                powerBtn.textContent = 'OFF';
                synthContainer.classList.remove('powered-on');
                synthContainer.classList.add('powered-off');
                
                // Stop tempo LED
                if (tempoLedInterval) {
                    clearInterval(tempoLedInterval);
                    tempoLedInterval = null;
                }
                const tempoLed = document.getElementById('tempoLed');
                tempoLed.classList.remove('blink');
                
                // Stop all audio
                if (arpInterval) {
                    pauseArp();
                }
                if (sequencerPlaying) {
                    stopSequencer();
                }
                
                // Stop all active notes
                const notesToStop = Array.from(activeNotes.keys());
                notesToStop.forEach(noteName => {
                    stopNote(noteName);
                });
                
                // Clear visual states
                document.querySelectorAll('.white-key, .black-key').forEach(key => {
                    key.classList.remove('playing');
                });
            }
            autoSave();
        });
        
        // Save/Load Song (complete project with samples and patterns)
        // Local save/load
        document.getElementById('saveLocalBtn').addEventListener('click', saveLocal);
        document.getElementById('loadLocalBtn').addEventListener('click', () => {
            document.getElementById('loadSongFile').click();
        });
        
        // Google Drive save/load
        document.getElementById('saveDriveBtn').addEventListener('click', saveToDrive);
        document.getElementById('loadDriveBtn').addEventListener('click', loadFromDrive);
        document.getElementById('loadSongFile').addEventListener('change', (e) => {
            loadSong(e.target.files[0]);
        });

        function saveLocal() {
            try {
                console.log('Saving song locally...');
                const songData = createSongData();
                
                // Create and download JSON file
                const json = JSON.stringify(songData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dPaul-MKIII-Song-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Song saved successfully');
                updateNoteDisplay('SONG SAVED');
                setTimeout(() => updateNoteDisplay('---'), 2000);
            } catch (error) {
                console.error('Error saving song:', error);
                updateNoteDisplay('SAVE ERROR');
                setTimeout(() => updateNoteDisplay('---'), 2000);
            }
        }

        // Google Drive Integration
        let gapiLoaded = false;
        let gisLoaded = false;
        let tokenClient;
        let accessToken = null;

        // Load Google API scripts
        function loadGoogleAPIs() {
            return new Promise((resolve) => {
                // Load GAPI
                const gapiScript = document.createElement('script');
                gapiScript.src = 'https://apis.google.com/js/api.js';
                gapiScript.onload = () => {
                    gapi.load('client', async () => {
                        await gapi.client.init({
                            apiKey: 'YOUR_API_KEY_HERE', // User needs to add their own
                            discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
                        });
                        gapiLoaded = true;
                        checkAndResolve();
                    });
                };
                document.head.appendChild(gapiScript);

                // Load GIS
                const gisScript = document.createElement('script');
                gisScript.src = 'https://accounts.google.com/gsi/client';
                gisScript.onload = () => {
                    tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: 'YOUR_CLIENT_ID_HERE.apps.googleusercontent.com', // User needs to add their own
                        scope: 'https://www.googleapis.com/auth/drive.file',
                        callback: ''
                    });
                    gisLoaded = true;
                    checkAndResolve();
                };
                document.head.appendChild(gisScript);

                function checkAndResolve() {
                    if (gapiLoaded && gisLoaded) resolve();
                }
            });
        }

        async function saveToDrive() {
            try {
                // Load APIs if not already loaded
                if (!gapiLoaded || !gisLoaded) {
                    updateNoteDisplay('LOADING DRIVE...');
                    await loadGoogleAPIs();
                }

                // Get access token
                if (!accessToken) {
                    await new Promise((resolve) => {
                        tokenClient.callback = (response) => {
                            if (response.error) {
                                throw new Error(response.error);
                            }
                            accessToken = response.access_token;
                            resolve();
                        };
                        tokenClient.requestAccessToken();
                    });
                }

                // Create song data
                const songData = createSongData();
                const jsonContent = JSON.stringify(songData, null, 2);
                const fileName = `dPaul-MKIII-${new Date().toISOString().slice(0,10)}.json`;

                // Upload to Google Drive
                const file = new Blob([jsonContent], { type: 'application/json' });
                const metadata = {
                    name: fileName,
                    mimeType: 'application/json'
                };

                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', file);

                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    },
                    body: form
                });

                if (response.ok) {
                    updateNoteDisplay('SAVED TO DRIVE');
                    setTimeout(() => updateNoteDisplay('---'), 2000);
                } else {
                    throw new Error('Drive upload failed');
                }
            } catch (error) {
                console.error('Error saving to Drive:', error);
                updateNoteDisplay('DRIVE ERROR');
                setTimeout(() => updateNoteDisplay('---'), 2000);
                
                // Fallback to local save
                if (confirm('Google Drive save failed. Save locally instead?')) {
                    saveLocal();
                }
            }
        }

        async function loadFromDrive() {
            try {
                // Load APIs if not already loaded
                if (!gapiLoaded || !gisLoaded) {
                    updateNoteDisplay('LOADING DRIVE...');
                    await loadGoogleAPIs();
                }

                // Get access token
                if (!accessToken) {
                    await new Promise((resolve) => {
                        tokenClient.callback = (response) => {
                            if (response.error) {
                                throw new Error(response.error);
                            }
                            accessToken = response.access_token;
                            resolve();
                        };
                        tokenClient.requestAccessToken();
                    });
                }

                // List files
                const response = await gapi.client.drive.files.list({
                    pageSize: 10,
                    fields: 'files(id, name, modifiedTime)',
                    q: "name contains 'dPaul-MKIII' and mimeType='application/json'"
                });

                const files = response.result.files;
                if (!files || files.length === 0) {
                    updateNoteDisplay('NO FILES FOUND');
                    setTimeout(() => updateNoteDisplay('---'), 2000);
                    return;
                }

                // Show file picker (simple - just use most recent)
                const file = files[0]; // Most recent file
                
                // Download file
                const downloadResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                const songData = await downloadResponse.json();
                applySongData(songData);

                updateNoteDisplay('LOADED FROM DRIVE');
                setTimeout(() => updateNoteDisplay('---'), 2000);
            } catch (error) {
                console.error('Error loading from Drive:', error);
                updateNoteDisplay('DRIVE ERROR');
                setTimeout(() => updateNoteDisplay('---'), 2000);
            }
        }

        // Helper function to create song data
        function createSongData() {
            if (!file) {
                console.log('No file selected');
                return;
            }
            
            console.log('Loading song:', file.name);
            const reader = new FileReader();
            
            reader.onerror = (error) => {
                console.error('FileReader error:', error);
                updateNoteDisplay('LOAD ERROR');
                setTimeout(() => updateNoteDisplay('---'), 2000);
            };
            
            reader.onload = (e) => {
                try {
                    console.log('File read complete, parsing JSON...');
                    const songData = JSON.parse(e.target.result);
                    console.log('Song data loaded:', songData);
                    
                    initAudio();
                    
                    // Load settings
                    if (masterGain) masterGain.gain.value = songData.settings.volume || 0.7;
                    if (drumGain) drumGain.gain.value = songData.settings.drumVolume || 0.7;
                    if (delayNode) delayNode.delayTime.value = songData.settings.delay || 0.3;
                    if (feedbackGain) feedbackGain.gain.value = songData.settings.feedback || 0.3;
                    if (filterNode) {
                        filterNode.frequency.value = songData.settings.filter || 2000;
                        filterNode.Q.value = songData.settings.resonance || 1;
                    }
                    
                    currentOctave = songData.settings.currentOctave || 4;
                    currentWaveform = songData.settings.currentWaveform || 'sawtooth';
                    arpEnabled = songData.settings.arpEnabled || false;
                    syncEnabled = songData.settings.syncEnabled || false;
                    tempo = songData.settings.tempo || 120;
                    pitchHoldEnabled = songData.settings.pitchHoldEnabled || false;
                    
                    // Load sequencer steps
                    if (songData.settings.sequencerSteps) {
                        setSequencerSteps(songData.settings.sequencerSteps);
                    }
                    
                    // Load drum volumes
                    if (songData.drumVolumes) {
                        drumVolumes = songData.drumVolumes;
                    }
                    
                    // Load sequencer patterns
                    if (songData.sequencerPattern) {
                        sequencerPattern = songData.sequencerPattern;
                    }
                    
                    // Load sampler settings
                    if (songData.sampler) {
                        samplePitch = songData.sampler.pitch || 0;
                        sampleSpeed = songData.sampler.speed || 1.0;
                        sampleFilter = songData.sampler.filter || 20000;
                        sampleReverse = songData.sampler.reverse || false;
                        sampleLoop = songData.sampler.loop || false;
                    }
                    
                    // Load samples
                    if (songData.samples) {
                        Object.keys(songData.samples).forEach(key => {
                            const sampleData = songData.samples[key];
                            const buffer = audioContext.createBuffer(
                                sampleData.numberOfChannels,
                                sampleData.length,
                                sampleData.sampleRate
                            );
                            
                            for (let i = 0; i < sampleData.numberOfChannels; i++) {
                                buffer.getChannelData(i).set(sampleData.channelData[i]);
                            }
                            
                            sampleBuffers[key] = buffer;
                            
                            // Update visual
                            const pad = document.querySelector(`.sample-pad[data-sample="${key}"]`);
                            if (pad) pad.classList.add('loaded');
                        });
                    }
                    
                    // Update all UI elements
                    updateOctaveDisplay();
                    updateTempoDisplay();
                    updateSequencerDisplay();
                    
                    // Update waveform buttons
                    document.querySelectorAll('.waveform-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.waveform === currentWaveform) {
                            btn.classList.add('active');
                        }
                    });
                    
                    // Update knobs
                    document.querySelectorAll('.knob').forEach(updateKnob);
                    
                    // Update switches
                    document.getElementById('arpSwitch').classList.toggle('active', arpEnabled);
                    document.getElementById('arpLight').classList.toggle('active', arpEnabled);
                    document.getElementById('syncBtn').classList.toggle('active', syncEnabled);
                    document.getElementById('pitchHoldBtn').classList.toggle('active', pitchHoldEnabled);
                    // Sampler switches removed from UI
                    
                    updateNoteDisplay('SONG LOADED');
                    setTimeout(() => updateNoteDisplay('---'), 2000);
                    
                } catch (error) {
                    console.error('Error loading song:', error);
                    updateNoteDisplay('LOAD ERROR');
                    setTimeout(() => updateNoteDisplay('---'), 2000);
                }
            };
            
            reader.readAsText(file);
        }

        // Load saved settings
        loadSettings();
        
        document.querySelectorAll('.knob').forEach(updateKnob);
        
        console.log('Synth initialization complete!');
        }); // End DOMContentLoaded
        
        // EMERGENCY BACKUP: Try again after a delay
        setTimeout(function() {
            console.log('EMERGENCY BACKUP: Trying to build keyboard after 1 second...');
            const container = document.getElementById('pianoKeys');
            console.log('Emergency check - container:', container);
            if (container && container.children.length === 0) {
                console.log('Container empty! Calling buildKeyboard again...');
                buildKeyboard();
            }
        }, 1000);
    </script>

    <!-- Wavetable Browser Modal -->
    <div id="wavetableModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:9999;align-items:center;justify-content:center;">
        <div class="wt-modal-inner">
            <div class="wt-modal-header">
                <h2>WAVETABLE BROWSER</h2>
                <button class="wt-close-btn" id="wtCloseBtn">X CLOSE</button>
            </div>
            <div class="wt-search-bar">
                <input type="text" id="wtSearch" placeholder="Search wavetables..." />
                <label class="wt-upload-label">LOAD .WAV<input type="file" id="wtFileInput" accept=".wav" style="display:none" /></label>
                <span class="wt-status" id="wtStatus">Ready</span>
            </div>
            <div class="wt-grid" id="wtGrid"></div>
            <div class="wt-current-label" id="wtCurrentLabel">ACTIVE: None</div>
        </div>
    </div>

    <script>
    (function() {

        // All wavetables are generated mathematically - no internet required, no CORS issues
        function makeWave(fn, category) {
            return { gen: fn, category: category || 'Built-in' };
        }

        var TWO_PI = Math.PI * 2;
        var N = 2048; // wavetable size

        // Helper: build PeriodicWave from a harmonic recipe { real: [], imag: [] }
        function buildPeriodicWave(realArr, imagArr) {
            var ctx = window.audioContext;
            if (!ctx) { ctx = new AudioContext(); window.audioContext = ctx; }
            var r = new Float32Array(N);
            var im = new Float32Array(N);
            for (var i = 0; i < Math.min(realArr.length, N); i++) r[i] = realArr[i];
            for (var i = 0; i < Math.min(imagArr.length, N); i++) im[i] = imagArr[i];
            return ctx.createPeriodicWave(r, im, { disableNormalization: false });
        }

        // Helper: generate harmonics from a time-domain waveform function
        function waveformToPeriodicWave(fn) {
            var ctx = window.audioContext;
            if (!ctx) { ctx = new AudioContext(); window.audioContext = ctx; }
            var real = new Float32Array(N);
            var imag = new Float32Array(N);
            var samples = new Float32Array(N);
            for (var i = 0; i < N; i++) samples[i] = fn(i / N);
            // DFT for first 512 harmonics
            for (var h = 1; h < 512; h++) {
                var re = 0, im2 = 0;
                for (var n = 0; n < N; n++) {
                    var a = (TWO_PI * h * n) / N;
                    re += samples[n] * Math.cos(a);
                    im2 -= samples[n] * Math.sin(a);
                }
                real[h] = (re / N) * 2;
                imag[h] = (im2 / N) * 2;
            }
            return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
        }

        // Wavetable definitions - each has a name, category, and gen() function
        var WAVES = [
            // ── Sawtooth variants ──
            { name: 'Bright Saw',    category: 'Sawtooth',   gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<64;h++){r.push(0);im.push(1/h);}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Soft Saw',      category: 'Sawtooth',   gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<32;h++){r.push(0);im.push(1/(h*h));}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Super Saw',     category: 'Sawtooth',   gen: function() {
                return waveformToPeriodicWave(function(t){
                    var v=0;
                    for(var d=-2;d<=2;d++) v+=(((t+d*0.02)%1)*2-1);
                    return v/5;
                });
            }},
            // ── Square variants ──
            { name: 'Square Odd',    category: 'Square',     gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<64;h++){r.push(0);im.push(h%2===1?1/h:0);}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Square Soft',   category: 'Square',     gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<16;h++){r.push(0);im.push(h%2===1?1/(h*h):0);}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Pulse 25%',     category: 'Square',     gen: function() {
                return waveformToPeriodicWave(function(t){ return t<0.25?1:-1; });
            }},
            // ── Triangle variants ──
            { name: 'Triangle',      category: 'Triangle',   gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<64;h++){var s=(h%2===1)?Math.pow(-1,(h-1)/2)/(h*h):0;r.push(s);im.push(0);}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Tri Bright',    category: 'Triangle',   gen: function() {
                return waveformToPeriodicWave(function(t){
                    return t<0.5?4*t-1:3-4*t;
                });
            }},
            // ── Organ / Hammond style ──
            { name: 'Organ 1',       category: 'Organ',      gen: function() {
                var r=[0,0,0,0,0,0,0,0,0], im=[0,0.8,0,0.5,0,0.3,0,0.2,0.1];
                return buildPeriodicWave(r,im);
            }},
            { name: 'Organ 2',       category: 'Organ',      gen: function() {
                var r=[0,0,0,0,0,0,0,0,0], im=[0,1,0,0.8,0,0.5,0,0.1,0.3];
                return buildPeriodicWave(r,im);
            }},
            { name: 'Drawbar',       category: 'Organ',      gen: function() {
                var r=[0], im=[0];
                var drawbars=[0,0.8,1,0.6,0.4,0,0.2,0,0.1];
                for(var h=1;h<9;h++){r.push(0);im.push(drawbars[h]||0);}
                return buildPeriodicWave(r,im);
            }},
            // ── Bell / Metallic ──
            { name: 'Bell',          category: 'Bell',       gen: function() {
                return waveformToPeriodicWave(function(t){
                    return Math.sin(TWO_PI*t)+0.5*Math.sin(TWO_PI*2.756*t)+
                           0.25*Math.sin(TWO_PI*5.404*t)+0.1*Math.sin(TWO_PI*8.933*t);
                });
            }},
            { name: 'Marimba',       category: 'Bell',       gen: function() {
                return waveformToPeriodicWave(function(t){
                    return Math.sin(TWO_PI*t)+0.4*Math.sin(TWO_PI*4*t)+
                           0.1*Math.sin(TWO_PI*10*t);
                });
            }},
            // ── Vocal / Formant ──
            { name: 'Vocal Ah',      category: 'Vocal',      gen: function() {
                return waveformToPeriodicWave(function(t){
                    return 0.7*Math.sin(TWO_PI*t)+0.5*Math.sin(TWO_PI*2*t)+
                           0.8*Math.sin(TWO_PI*3*t)+0.3*Math.sin(TWO_PI*4*t)+
                           0.6*Math.sin(TWO_PI*8*t)+0.2*Math.sin(TWO_PI*13*t);
                });
            }},
            { name: 'Vocal Ee',      category: 'Vocal',      gen: function() {
                return waveformToPeriodicWave(function(t){
                    return 0.5*Math.sin(TWO_PI*t)+0.3*Math.sin(TWO_PI*2*t)+
                           0.9*Math.sin(TWO_PI*5*t)+0.7*Math.sin(TWO_PI*10*t)+
                           0.5*Math.sin(TWO_PI*14*t);
                });
            }},
            { name: 'Vocal Oh',      category: 'Vocal',      gen: function() {
                return waveformToPeriodicWave(function(t){
                    return 0.9*Math.sin(TWO_PI*t)+0.6*Math.sin(TWO_PI*2*t)+
                           0.2*Math.sin(TWO_PI*3*t)+0.5*Math.sin(TWO_PI*6*t)+
                           0.1*Math.sin(TWO_PI*9*t);
                });
            }},
            // ── Strings / Ensemble ──
            { name: 'Strings',       category: 'Strings',    gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<20;h++){r.push(0);im.push(Math.pow(0.85,h)*( (h%2===1)?1:-0.5 ));}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Cello',         category: 'Strings',    gen: function() {
                var r=[0], im=[0];
                var amp=[0,1,0.6,0.4,0.8,0.2,0.5,0.1,0.3,0.05];
                for(var h=1;h<10;h++){r.push(0);im.push(amp[h]);}
                return buildPeriodicWave(r,im);
            }},
            // ── Wind ──
            { name: 'Flute',         category: 'Wind',       gen: function() {
                var r=[0], im=[0,1,0.3,0.05,0.01];
                r.push(0,0,0,0); 
                return buildPeriodicWave(r,im);
            }},
            { name: 'Clarinet',      category: 'Wind',       gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<16;h++){r.push(0);im.push(h%2===1?1/h:1/(h*4));}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Oboe',          category: 'Wind',       gen: function() {
                var r=[0], im=[0];
                var amp=[0,1,0.8,0.7,0.5,0.6,0.4,0.3,0.2,0.15,0.1];
                for(var h=1;h<11;h++){r.push(0);im.push(amp[h]);}
                return buildPeriodicWave(r,im);
            }},
            // ── FM / Digital ──
            { name: 'FM Bass',       category: 'FM',         gen: function() {
                return waveformToPeriodicWave(function(t){
                    var mod = Math.sin(TWO_PI*2*t)*2.5;
                    return Math.sin(TWO_PI*t + mod);
                });
            }},
            { name: 'FM Bell',       category: 'FM',         gen: function() {
                return waveformToPeriodicWave(function(t){
                    var mod = Math.sin(TWO_PI*3.5*t)*3;
                    return Math.sin(TWO_PI*t + mod);
                });
            }},
            { name: 'FM Growl',      category: 'FM',         gen: function() {
                return waveformToPeriodicWave(function(t){
                    var mod = Math.sin(TWO_PI*4*t)*5;
                    return Math.sin(TWO_PI*t + mod);
                });
            }},
            // ── Wavetable morphs ──
            { name: 'Saw-Sine',      category: 'Morph',      gen: function() {
                return waveformToPeriodicWave(function(t){
                    var saw = t*2-1;
                    var sine = Math.sin(TWO_PI*t);
                    return saw*0.5 + sine*0.5;
                });
            }},
            { name: 'Pulse-Tri',     category: 'Morph',      gen: function() {
                return waveformToPeriodicWave(function(t){
                    var pulse = t<0.3?1:-1;
                    var tri = t<0.5?4*t-1:3-4*t;
                    return pulse*0.5 + tri*0.5;
                });
            }},
            { name: 'Harmonic Odd',  category: 'Additive',   gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<32;h++){r.push(0);im.push(h%2===1?Math.pow(0.7,h):0);}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Harmonic Even', category: 'Additive',   gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<32;h++){r.push(0);im.push(h%2===0?Math.pow(0.7,h):0);}
                return buildPeriodicWave(r,im);
            }},
            { name: 'Overtone Rich', category: 'Additive',   gen: function() {
                var r=[0], im=[0];
                for(var h=1;h<48;h++){r.push(0);im.push(1/(Math.pow(h,0.5)));}
                return buildPeriodicWave(r,im);
            }},
            // ── Synth leads ──
            { name: 'Sync Lead',     category: 'Lead',       gen: function() {
                return waveformToPeriodicWave(function(t){
                    var ratio=3.5;
                    return Math.sin(TWO_PI*t)*Math.max(0,Math.cos(TWO_PI*ratio*t));
                });
            }},
            { name: 'Growl Bass',    category: 'Lead',       gen: function() {
                return waveformToPeriodicWave(function(t){
                    var v = t*2-1;
                    return v + 0.3*Math.sin(TWO_PI*7*t) + 0.2*Math.sin(TWO_PI*13*t);
                });
            }},
        ];

        var allWaves = WAVES.slice();
        var filteredWaves = allWaves.slice();
        var activeWtName = null;
        window.currentWavetablePeriodicWave = null;

        var modal  = document.getElementById('wavetableModal');
        var grid   = document.getElementById('wtGrid');
        var search = document.getElementById('wtSearch');
        var status = document.getElementById('wtStatus');
        var label  = document.getElementById('wtCurrentLabel');
        var fileIn = document.getElementById('wtFileInput');

        function buildGrid(list) {
            grid.innerHTML = '';
            status.textContent = list.length + ' waves';
            list.forEach(function(w) {
                var card = document.createElement('div');
                card.className = 'wt-card' + (w.name === activeWtName ? ' active' : '');
                card.innerHTML = '<div class="wt-name">' + w.name + '</div><div class="wt-sub">' + (w.category || 'Built-in') + '</div>';
                card.addEventListener('click', function() { selectWave(w, card); });
                grid.appendChild(card);
            });
        }

        function wavFileToPeriodicWave(arrayBuffer) {
            var ctx = window.audioContext;
            if (!ctx) { ctx = new AudioContext(); window.audioContext = ctx; }
            return ctx.decodeAudioData(arrayBuffer).then(function(decoded) {
                var raw = decoded.getChannelData(0);
                var size = 2048;
                var resampled = new Float32Array(size);
                for (var i = 0; i < size; i++) {
                    resampled[i] = raw[Math.floor(i * raw.length / size)];
                }
                var real = new Float32Array(size);
                var imag = new Float32Array(size);
                for (var h = 1; h < 512; h++) {
                    var re = 0, im2 = 0;
                    for (var n = 0; n < size; n++) {
                        var angle = (TWO_PI * h * n) / size;
                        re += resampled[n] * Math.cos(angle);
                        im2 -= resampled[n] * Math.sin(angle);
                    }
                    real[h] = (re / size) * 2;
                    imag[h] = (im2 / size) * 2;
                }
                return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
            });
        }

        function applyWavetableToSynth(pw, name) {
            window.currentWavetablePeriodicWave = pw;
            activeWtName = name;
            document.querySelectorAll('.waveform-btn').forEach(function(b) { b.classList.remove('active'); });
            var wtBtn = document.getElementById('waveWavetable');
            if (wtBtn) wtBtn.classList.add('active');
            if (typeof currentWaveform !== 'undefined') { currentWaveform = 'wavetable'; }
            label.textContent = 'ACTIVE: ' + name;
        }

        function selectWave(w, card) {
            // Make sure audio context is running
            if (!window.audioContext) {
                window.audioContext = new AudioContext();
            }
            if (window.audioContext.state === 'suspended') window.audioContext.resume();
            try {
                var pw = w.gen();
                applyWavetableToSynth(pw, w.name);
                document.querySelectorAll('.wt-card').forEach(function(c) { c.classList.remove('active'); });
                card.classList.add('active');
                setTimeout(function() { modal.style.display = 'none'; }, 300);
            } catch(err) {
                console.error('Wavetable generation error:', err);
            }
        }

        fileIn.addEventListener('change', function(e) {
            var file = e.target.files[0];
            if (!file) return;
            file.arrayBuffer().then(wavFileToPeriodicWave).then(function(pw) {
                var name = file.name.replace('.wav','');
                applyWavetableToSynth(pw, name + ' (custom)');
                var custom = { name: name, url: URL.createObjectURL(file), category: 'Custom' };
                allWaves.unshift(custom);
                filteredWaves = allWaves.slice();
                buildGrid(filteredWaves);
                modal.style.display = 'none';
            }).catch(function(err) { console.error(err); status.textContent = 'Error!'; });
        });

        search.addEventListener('input', function() {
            var q = search.value.toLowerCase();
            filteredWaves = allWaves.filter(function(w) { return w.name.toLowerCase().indexOf(q) >= 0; });
            buildGrid(filteredWaves);
        });

        // Open modal when WTBL button clicked (capture phase beats generic handler)
        document.addEventListener('DOMContentLoaded', function() {
            var wtBtn = document.getElementById('waveWavetable');
            if (wtBtn) {
                wtBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    modal.style.display = 'flex';
                    search.value = '';
                    filteredWaves = allWaves.slice();
                    buildGrid(filteredWaves);
                    if (!window.currentWavetablePeriodicWave) wtBtn.classList.remove('active');
                }, true);
            }
            document.getElementById('wtCloseBtn').addEventListener('click', function() {
                modal.style.display = 'none';
                if (!window.currentWavetablePeriodicWave) {
                    var b = document.getElementById('waveWavetable');
                    if (b) b.classList.remove('active');
                }
            });
            modal.addEventListener('click', function(e) {
                if (e.target === modal) modal.style.display = 'none';
            });
        });

        // Patch AudioContext.createOscillator so wavetable PeriodicWave is applied on start
        var _origCreate = AudioContext.prototype.createOscillator;
        AudioContext.prototype.createOscillator = function() {
            var osc = _origCreate.call(this);
            var _origStart = osc.start.bind(osc);
            osc.start = function(when) {
                var wf = (typeof currentWaveform !== 'undefined') ? currentWaveform : window.currentWaveform;
                if (wf === 'wavetable' && window.currentWavetablePeriodicWave) {
                    try { osc.setPeriodicWave(window.currentWavetablePeriodicWave); } catch(e) {}
                }
                _origStart(when !== undefined ? when : 0);
            };
            return osc;
        };

        buildGrid(filteredWaves);
    })();
    </script>
</body>
</html>